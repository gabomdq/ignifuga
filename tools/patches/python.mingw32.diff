Index: Python/pythonrun.c
===================================================================
--- Python/pythonrun.c	(revisión: 29)
+++ Python/pythonrun.c	(copia de trabajo)
@@ -158,6 +158,15 @@
         return;
     initialized = 1;
 
+#ifdef __MINGW32__
+    // Redirect stdout,stderr to the console
+    AttachConsole(ATTACH_PARENT_PROCESS);
+    freopen("CONOUT$", "wb", stdout);
+    freopen("CONOUT$", "wb", stderr);
+    FILE *_ERR = GetStdHandle(STD_ERROR_HANDLE);
+    FILE *_OUT = GetStdHandle(STD_OUTPUT_HANDLE);
+#endif
+
     if ((p = Py_GETENV("PYTHONDEBUG")) && *p != '\0')
         Py_DebugFlag = add_flag(Py_DebugFlag, p);
     if ((p = Py_GETENV("PYTHONVERBOSE")) && *p != '\0')
Index: Python/pystrtod.c
===================================================================
--- Python/pystrtod.c	(revisión: 29)
+++ Python/pystrtod.c	(copia de trabajo)
@@ -126,7 +126,6 @@
 {
     char *fail_pos;
     double val = -1.0;
-    struct lconv *locale_data;
     const char *decimal_point;
     size_t decimal_point_len;
     const char *p, *decimal_point_pos;
@@ -138,8 +137,7 @@
 
     fail_pos = NULL;
 
-    locale_data = localeconv();
-    decimal_point = locale_data->decimal_point;
+    decimal_point = ".";
     decimal_point_len = strlen(decimal_point);
 
     assert(decimal_point_len != 0);
@@ -375,8 +373,7 @@
 Py_LOCAL_INLINE(void)
 change_decimal_from_locale_to_dot(char* buffer)
 {
-    struct lconv *locale_data = localeconv();
-    const char *decimal_point = locale_data->decimal_point;
+    const char *decimal_point = ".";
 
     if (decimal_point[0] != '.' || decimal_point[1] != 0) {
         size_t decimal_point_len = strlen(decimal_point);
Index: Python/thread.c
===================================================================
--- Python/thread.c	(revisión: 29)
+++ Python/thread.c	(copia de trabajo)
@@ -7,6 +7,16 @@
 
 #include "Python.h"
 
+#ifdef __MINGW32__
+/* GCC 4.4+ (mingw) support posix threads!
+  Note: macro __MINGW_GCC is defined for GCC 4.4+ but
+  not for GCC 3.4.5 (last stable from 3.x )
+  Instead to use __MINGW_GCC we will use more common
+  __MINGW32__ to prevent case when in GCC 3.4.5 build
+  envirionment is installed posix thread package.
+ */
+# undef HAVE_PTHREAD_H
+#endif
 
 #ifndef _POSIX_THREADS
 /* This means pthreads are not implemented in libc headers, hence the macro
Index: Python/dynload_win.c
===================================================================
--- Python/dynload_win.c	(revisión: 29)
+++ Python/dynload_win.c	(copia de trabajo)
@@ -11,9 +11,11 @@
 #include "importdl.h"
 #include <windows.h>
 
-// "activation context" magic - see dl_nt.c...
+#ifdef Py_ENABLE_SHARED
+/* "activation context" magic - see dl_nt.c... */
 extern ULONG_PTR _Py_ActivateActCtx();
 void _Py_DeactivateActCtx(ULONG_PTR cookie);
+#endif
 
 const struct filedescr _PyImport_DynLoadFiletab[] = {
 #ifdef _DEBUG
@@ -25,24 +27,6 @@
 };
 
 
-/* Case insensitive string compare, to avoid any dependencies on particular
-   C RTL implementations */
-
-static int strcasecmp (char *string1, char *string2)
-{
-    int first, second;
-
-    do {
-        first  = tolower(*string1);
-        second = tolower(*string2);
-        string1++;
-        string2++;
-    } while (first && first == second);
-
-    return (first - second);
-}
-
-
 /* Function to return the name of the "python" DLL that the supplied module
    directly imports.  Looks through the list of imported modules and
    returns the first entry that starts with "python" (case sensitive) and
@@ -190,11 +174,15 @@
                             sizeof(pathbuf),
                             pathbuf,
                             &dummy)) {
+#ifdef Py_ENABLE_SHARED
             ULONG_PTR cookie = _Py_ActivateActCtx();
+#endif
             /* XXX This call doesn't exist in Windows CE */
             hDLL = LoadLibraryEx(pathname, NULL,
                                  LOAD_WITH_ALTERED_SEARCH_PATH);
+#ifdef Py_ENABLE_SHARED
             _Py_DeactivateActCtx(cookie);
+#endif
         }
 
         /* restore old error mode settings */
Index: Python/getplatform.c
===================================================================
--- Python/getplatform.c	(revisión: 29)
+++ Python/getplatform.c	(copia de trabajo)
@@ -1,6 +1,31 @@
-
 #include "Python.h"
 
+#ifdef ANDROID
+#include <sys/utsname.h>
+#include <string.h>
+
+char _PLATFORM[20]={0}; // taken as base linux-armv7l-2.6
+
+const char *
+Py_GetPlatform(void)
+{
+    if (_PLATFORM[0]!=0)
+	return _PLATFORM;
+
+    struct utsname u;
+    int i;
+    if ( uname(&u) < 0 )
+	return "unknown";
+
+    strcat (_PLATFORM, u.sysname);
+    strcat (_PLATFORM, "-");
+    strcat (_PLATFORM, u.machine);
+    for (i=0; _PLATFORM[i]; i++)
+	_PLATFORM[i]=tolower(_PLATFORM[i]);
+    return _PLATFORM;
+}
+#else
+
 #ifndef PLATFORM
 #define PLATFORM "unknown"
 #endif
@@ -10,3 +35,4 @@
 {
 	return PLATFORM;
 }
+#endif
Index: configure
===================================================================
--- configure	(revisión: 29)
+++ configure	(copia de trabajo)
@@ -13673,7 +13673,7 @@
   $as_echo_n "(cached) " >&6
 else
   if test "$cross_compiling" = yes; then :
-  ac_cv_have_long_long_format=no
+  ac_cv_have_long_long_format=yes
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
@@ -13738,15 +13738,15 @@
 fi
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for %zd printf() format support" >&5
-$as_echo_n "checking for %zd printf() format support... " >&6; }
-if ${ac_cv_have_size_t_format+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "$cross_compiling" = yes; then :
-  ac_cv_have_size_t_format="cross -- assuming yes"
+#{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for %zd printf() format support" >&5
+#$as_echo_n "checking for %zd printf() format support... " >&6; }
+#if ${ac_cv_have_size_t_format+:} false; then :
+#  $as_echo_n "(cached) " >&6
+#else
+#  if test "$cross_compiling" = yes; then :
+#  ac_cv_have_size_t_format="cross -- assuming yes"
 
-else
+#else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -13793,17 +13793,9 @@
 fi
 rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
   conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
+#fi
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_size_t_format" >&5
-$as_echo "$ac_cv_have_size_t_format" >&6; }
-if test "$ac_cv_have_size_t_format" != no ; then
 
-$as_echo "#define PY_FORMAT_SIZE_T \"z\"" >>confdefs.h
-
-fi
-
 ac_fn_c_check_type "$LINENO" "socklen_t" "ac_cv_type_socklen_t" "
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
Index: Include/pyport.h
===================================================================
--- Include/pyport.h	(revisión: 29)
+++ Include/pyport.h	(copia de trabajo)
@@ -656,6 +656,137 @@
 #endif /* 0 */
 
 
+#ifdef __MINGW32__
+/* FIXME: some of next definitions specific to gcc(mingw build) can be
+   generalized on definitions of _WIN32 or WIN32 and to be common for
+   all windows build instead explicitly to define only for non-autotools
+   based builds (see PC/pyconfig.h for details). */
+#if defined(_WIN64)
+#  define MS_WIN64
+#endif
+#if !defined(MS_WIN32) && defined(_WIN32)
+#  define MS_WIN32
+#endif
+#if !defined(MS_WIN32) && defined(_WIN32)
+#  define MS_WIN32
+#endif
+#if !defined(MS_WINDOWS) && defined(MS_WIN32)
+#  define MS_WINDOWS
+#endif
+
+#ifndef PYTHONPATH
+#  define PYTHONPATH ".\\DLLs;.\\lib;.\\lib\\plat-win;.\\lib\\lib-tk"
+#endif
+
+/* python 2.6+ requires Windows 2000 or greater. */
+#define Py_WINVER 0x0500
+
+#if defined(Py_BUILD_CORE) || defined(Py_BUILD_CORE_MODULE)
+/* FIXME if NTDDI_xxx is in use by mingw (see PC/pyconfig.h) */
+#ifndef WINVER
+#  define WINVER Py_WINVER
+#endif
+#ifndef _WIN32_WINNT
+#  define _WIN32_WINNT Py_WINVER
+#endif
+#endif
+
+#ifdef PLATFORM
+/*NOTE: if compile getplatform.c PLATFORM is set to MACHDEP that is
+  "win" for mingw build (see respective comment in configure.in). */
+# undef PLATFORM
+#endif
+/* always set to "win32" - see PC/pyconfig.h */
+#define PLATFORM "win32"
+
+#if defined(MS_WIN64)
+#  define SIZEOF_HKEY 8
+#elif defined(MS_WIN32)
+#  define SIZEOF_HKEY 4
+#endif
+
+/*NOTE: mingw has isinf as macro defined in math.h.
+  Since PC/pyconfig.h define Py_IS_INFINITY(X) that cover HAVE_DECL_ISFINITE
+  here for Py_IS_INFINITY we define same as for MSVC build.
+  This makes HAVE_DECL_ISFINITE needless.
+  Also see commants in configure.in and pymath.h. */
+#define Py_IS_INFINITY(X) (!_finite(X) && !_isnan(X))
+
+#ifndef HAVE_LARGEFILE_SUPPORT
+/*
+  FIXME: on windows platforms:
+   - Python use PY_LONG_LONG(!) for Py_off_t (_fileio.c);
+   - HAVE_LARGEFILE_SUPPORT is defined in PC/pyconfig.h;
+   - PC/pyconfig.h define 4 for SIZEOF_OFF_T and 8 for SIZEOF_FPOS_T;
+   - If HAVE_LARGEFILE_SUPPORT isn't defined python will use off_t(!)
+   for Py_off_t (see fileobjects.c and bz2module.c).
+  Since for mingw configure detect 4 for size of "off_t" and 8 - for
+  "fpos_t" we has to define HAVE_LARGEFILE_SUPPORT too.
+  TODO: to test with AC_SYS_LARGEFILE and appropriate updates in
+  python code.
+*/
+#  define HAVE_LARGEFILE_SUPPORT
+#endif
+
+#if defined(Py_ENABLE_SHARED)
+#  define MS_COREDLL 1 /* deprecated old symbol, but still in use for windows code */
+#else
+#  define MS_NO_COREDLL 1
+#endif
+
+#if Py_UNICODE_SIZE == 2
+/* For mingw is 2 but FIXME: What about to raise error in configure if
+   unicode size isn't two ? Did python windows code support ucs4 ? */
+#  define Py_WIN_WIDE_FILENAMES
+#endif
+
+/* NOTE: Don't define HAVE_STDDEF_H.
+ * It is defined by PC/pyconfig.h and used by Include/Python.h
+ * (with comment For size_t?) but isn't required for mingw  */
+#define Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE
+
+/* All other defines from PC/pyconfig.h are in autoconf generated
+   pyconfig.h */
+#if 0
+/*FIXME:
+  MSDN:
+    "The getaddrinfo function was added to the ws2_32.dll on Windows XP
+    and later."
+  mingw:
+    getaddrinfo and getnameinfo is defined for WINVER >= 0x0501.
+  PC/pyconfig.h:
+    "Python 2.6+ requires Windows 2000 or greater"
+  So far so good but socketmodule.h define HAVE_GETADDRINFO and
+  HAVE_GETNAMEINFO under very specific condition :
+    # ifdef SIO_GET_MULTICAST_FILTER
+    #  include <MSTcpIP.h>
+  So the question is "Separate SDKs" required for w2k in MSVC build ?
+  TODO: resolve later, may by configure :-/. For now python code will
+  use fake implementation and if user define appropriate value for
+  WINVER - the functionas from C runtime.
+  For details see socketmodule.c .
+  */
+#ifndef HAVE_GETADDRINFO
+#  define HAVE_GETADDRINFO
+#endif
+#ifndef HAVE_GETNAMEINFO
+#  define HAVE_GETNAMEINFO
+#endif
+#endif
+
+/* Refer to <Modules/_math.h> .
+   For mingw host configure detect functions described as HAVE_XXX
+   in _math.h but as MSVC don't define them we will undefine HAVE_XXX
+   too to use _Py_* replacements same as MSVC build .
+ */
+#undef HAVE_ACOSH
+#undef HAVE_ASINH
+#undef HAVE_ATANH
+#undef HAVE_EXPM1
+#undef HAVE_LOG1P
+
+#endif /*def __MINGW32__*/
+
 /* On 4.4BSD-descendants, ctype functions serves the whole range of
  * wchar_t character set rather than single byte code points only.
  * This characteristic can break some operations of string object
@@ -709,12 +840,12 @@
 */
 
 /*
-  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+  MSVC windows port is handled in PC/pyconfig.h.
 
-  BeOS and cygwin are the only other autoconf platform requiring special
-  linkage handling and both of these use __declspec().
+  BeOS, mingw32 and cygwin use autoconf and require special
+  linkage handling and all of these use __declspec().
 */
-#if defined(__CYGWIN__) || defined(__BEOS__)
+#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BEOS__)
 #       define HAVE_DECLSPEC_DLL
 #endif
 
@@ -737,9 +868,17 @@
         /* Under Cygwin, auto-import functions to prevent compilation */
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
-#                       if !defined(__CYGWIN__)
+#                       if !defined(__CYGWIN__) && !defined(__MINGW32__)
 #                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
-#                       endif /* !__CYGWIN__ */
+#                       else
+#                               define PyAPI_FUNC(RTYPE) RTYPE
+#                       endif /* !__CYGWIN__  !__MINGW32__ */
+            /* NOTE: The issue3945 "compile error in _fileio.c (cygwin)"
+             * was resolved with modification of code.
+             * This issue was resolved for gcc(mingw) with enabling auto
+             * import feature. Since _fileio.c problem now disappear there
+             * is no more reasons to avoid dllimport for gcc(mingw).
+             */
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
Index: Include/objimpl.h
===================================================================
--- Include/objimpl.h	(revisión: 29)
+++ Include/objimpl.h	(copia de trabajo)
@@ -256,6 +256,12 @@
         Py_ssize_t gc_refs;
     } gc;
     long double dummy;  /* force worst-case alignment */
+#if defined(__MINGW32__)
+/* FIXME: what about 64-bit platforms ?
+ * see http://mail.python.org/pipermail/python-dev/2009-July/090724.html
+ */
+	double dummy1;
+#endif
 } PyGC_Head;
 
 extern PyGC_Head *_PyGC_generation0;
Index: Include/pymath.h
===================================================================
--- Include/pymath.h	(revisión: 29)
+++ Include/pymath.h	(copia de trabajo)
@@ -109,6 +109,8 @@
  *    non-infinite value v sitting in an 80-bit x87 register such that
  *    v becomes infinite when spilled from the register to 64-bit memory.
  * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
+ * FIXME: PC/pyconfig.h defines Py_IS_INFINITY as (!_finite(X) && !_isnan(X))
+ * so that above note isn't correct !!!
  */
 #ifndef Py_IS_INFINITY
 #  if defined HAVE_DECL_ISINF && HAVE_DECL_ISINF == 1
Index: configure.in
===================================================================
--- configure.in	(revisión: 29)
+++ configure.in	(copia de trabajo)
@@ -277,8 +285,28 @@
 # Set name for machine-dependent library files
 AC_SUBST(MACHDEP)
 AC_MSG_CHECKING(MACHDEP)
+dnl In addition $host_os may contain specific settings for some host systems
+dnl as example mingwNN{YYYY} but the host winNN. So we may set MACHDEP
+dnl to winNN in this case, i.e. different host systems from gnu autotools
+dnl point of view but same for python.
 if test -z "$MACHDEP"
 then
+   dnl set MACHDEP only on certain host systems
+   case $host in
+   *-*-mingw*)
+   dnl we use only case based on "host triplet"
+   ac_sys_system=ignore
+   dnl FIXME: what is correct:
+   dnl - PLATFORM is always "win32" (see define in PC/pyconfig.h )
+   dnl - getplatform.o is build with -DPLATFORM='"$(MACHDEP)"'
+   dnl - the platform specific files go in plat-$(MACHDEP)
+   dnl - but an item in PYTHONPATH is "plat-win" !!! oops
+   MACHDEP=win
+   ;;
+   esac
+fi
+if test -z "$MACHDEP"
+then
 	ac_sys_system=`uname -s`
 	if test "$ac_sys_system" = "AIX" \
 	-o "$ac_sys_system" = "UnixWare" -o "$ac_sys_system" = "OpenUNIX"; then
@@ -722,6 +750,10 @@
   *)
     enable_shared="no";;
   esac
+  case $host in
+  *-*-mingw*)
+    enable_shared="yes";;
+  esac
 fi
 AC_MSG_RESULT($enable_shared)
 
@@ -822,6 +854,14 @@
 	;;
 
   esac
+  case $host in
+    *-*-mingw*)
+          LDLIBRARY='libpython$(VERSION).dll.a'
+          DLLLIBRARY='libpython$(VERSION).dll'
+          dnl setup.py add it for mingw host
+          dnl BLDLIBRARY='-L. -lpython$(VERSION)'
+          ;;
+  esac
 else # shared is disabled
   case $ac_sys_system in
     CYGWIN*)
@@ -829,6 +869,10 @@
           LDLIBRARY='libpython$(VERSION).dll.a'
           ;;
   esac
+  case $host in
+    *-*-mingw*)
+          LDLIBRARY='libpython$(VERSION).a';;
+  esac
 fi
 
 AC_MSG_RESULT($LDLIBRARY)
@@ -889,6 +933,8 @@
 	esac
 fi
 
+dnl TODO: to move --with-pydebug earlier in script and to group
+dnl debug related statements togeder (if posible)
 # Check for --with-pydebug
 AC_MSG_CHECKING(for --with-pydebug)
 AC_ARG_WITH(pydebug, 
@@ -903,6 +949,29 @@
 else AC_MSG_RESULT(no); Py_DEBUG='false'
 fi],
 [AC_MSG_RESULT(no)])
+# FIXME: We define BUILDEXEEXT and LDLIBRARY above but:
+#  For debug versions MSVC build prepend suffix by '_d'.
+#  If we support this convention we may modify distutils(TODO).
+#  To support different build directories is good "--with-pydebug"
+#  to be earlier in the script(why i wrote this?).
+if test "x$Py_DEBUG" = xtrue; then
+  case $host in
+    dnl TODO: This is good to be where we define LDLIBRARY
+    dnl but --with-pydebug is defined too late in the script.
+    # Since Makefile.pre.in may isn't suitable for now we will not
+    # change LDLIBRARY.
+    *-*-mingw*)
+      BUILDEXEEXT=_d$BUILDEXEEXT
+      if test x$enable_shared = xyes; then
+        #LDLIBRARY='libpython$(VERSION)_d.dll.a'
+        DLLLIBRARY='libpython$(VERSION)_d.dll'
+      else # shared is disabled
+        #LDLIBRARY='libpython$(VERSION)_d.dll.a';;
+        :
+      fi
+      ;;
+  esac
+fi
 
 # XXX Shouldn't the code above that fiddles with BASECFLAGS and OPT be
 # merged with this chunk of code?
@@ -919,6 +988,8 @@
 
 # tweak OPT based on compiler and platform, only if the user didn't set
 # it on the command line
+# NOTE: If user set OPT at this point script ignore all previously set
+# options (not important - BeOS is depricated for python 2.6+).
 AC_SUBST(OPT)
 if test "${OPT-unset}" = "unset"
 then
@@ -991,6 +1062,10 @@
          alpha*)
                 BASECFLAGS="$BASECFLAGS -mieee"
                 ;;
+         *-*-mingw*)
+                #MSVC compatable storage layout for bitfields in structures
+                BASECFLAGS="$BASECFLAGS -mms-bitfields"
+                ;;
     esac
 
     case $ac_sys_system in
@@ -1123,8 +1198,15 @@
     ;;
 esac
 
+dnl NOTE: although Py_DEBUG is set earlier in the script we can't move
+dnl before "# tweak OPT based on compiler" - if user specify environment
+dnl variable OPT we will lost our settings!!!
+dnl FIXME: why script add debug definition to OPT instead to BASECFLAGS?
 if test "$Py_DEBUG" = 'true'; then
-  :
+  case $host in
+    dnl Same as in PC/pyconfig.h but order in opposite(Py_DEBUG=>-D_DEBUG).
+    *-*-mingw*) OPT="-D_DEBUG $OPT";;
+  esac
 else
   OPT="-DNDEBUG $OPT"
 fi
@@ -1311,6 +1393,20 @@
 AC_MSG_RESULT($ac_cv_pthread)
 fi
 
+if test "x$ac_cv_kpthread" = xno && \
+   test "x$ac_cv_kthread" = xno && \
+   test "x$ac_cv_pthread" = xno && \
+   test "x$ac_cv_pthread_is_default" = xno
+then
+	AC_MSG_CHECKING(for NT threads)
+	AC_CACHE_VAL(ac_cv_ntthread,
+	[AC_LINK_IFELSE(
+		AC_LANG_PROGRAM([], [_beginthread(0, 0, 0);]),
+	ac_cv_ntthread=yes,
+	ac_cv_ntthread=no)])
+	AC_MSG_RESULT([$ac_cv_ntthread])
+fi
+
 # If we have set a CC compiler flag for thread support then
 # check if it works for CXX, too.
 ac_cv_cxx_thread=no
@@ -1331,6 +1427,9 @@
 then 
   CXX="$CXX -pthread"
   ac_cv_cxx_thread=yes
+elif test "x$ac_cv_ntthread" = xyes
+then
+  ac_cv_cxx_thread=always
 fi
 
 if test $ac_cv_cxx_thread = yes
@@ -1372,7 +1471,7 @@
 sys/termio.h sys/time.h \
 sys/times.h sys/types.h sys/un.h sys/utsname.h sys/wait.h pty.h libutil.h \
 sys/resource.h netpacket/packet.h sysexits.h bluetooth.h \
-bluetooth/bluetooth.h linux/tipc.h spawn.h util.h)
+bluetooth/bluetooth.h linux/tipc.h spawn.h util.h winsock2.h)
 AC_HEADER_DIRENT
 AC_HEADER_MAJOR
 
@@ -1506,6 +1605,9 @@
 AC_MSG_RESULT($have_long_long)
 if test "$have_long_long" = yes ; then
 AC_CHECK_SIZEOF(long long, 8)
+  case $host in
+    *-*-mingw*) ac_cv_have_long_long_format=yes;;
+  esac
 fi
 
 AC_MSG_CHECKING(for long double support)
@@ -1581,19 +1683,20 @@
 elif test "$ac_cv_pthread" = "yes"
 then CC="$CC -pthread"
 fi
-AC_MSG_CHECKING(for pthread_t)
-have_pthread_t=no
-AC_COMPILE_IFELSE([
-  AC_LANG_PROGRAM([[#include <pthread.h>]], [[pthread_t x; x = *(pthread_t*)0;]])
-],[have_pthread_t=yes],[])
-AC_MSG_RESULT($have_pthread_t)
-if test "$have_pthread_t" = yes ; then
+dnl NOTE: avoid duplicate check for pthread_t(it is done in AC_CHECK_SIZEOF(pthread_t...) )
+dnl AC_MSG_CHECKING(for pthread_t)
+dnl have_pthread_t=no
+dnl AC_COMPILE_IFELSE([
+dnl   AC_LANG_PROGRAM([[#include <pthread.h>]], [[pthread_t x; x = *(pthread_t*)0;]])
+dnl ],[have_pthread_t=yes],[])
+dnl AC_MSG_RESULT($have_pthread_t)
+dnl if test "$have_pthread_t" = yes ; then
   AC_CHECK_SIZEOF(pthread_t, [], [
 #ifdef HAVE_PTHREAD_H
 #include <pthread.h>
 #endif
   ])
-fi
+dnl fi
 CC="$ac_save_cc"
 
 AC_MSG_CHECKING(for --enable-toolbox-glue)
@@ -1754,6 +1857,16 @@
 	CYGWIN*)   SO=.dll;;
 	*)	   SO=.so;;
 	esac
+	case $host in
+	*-*-mingw*)
+	#NOTE: see _PyImport_DynLoadFiletab in dynload_win.c
+	if test "x$Py_DEBUG" = xtrue; then
+		SO=_d.pyd
+	else
+		SO=.pyd
+	fi
+	;;
+	esac
 else
 	# this might also be a termcap variable, see #610332
         echo
@@ -1910,6 +2023,12 @@
 		LDCXXSHARED="g++ -shared";;
 	*)	LDSHARED="ld";;
 	esac
+	case $host in
+	*-*-mingw*)
+		LDSHARED='$(CC) -shared -Wl,--enable-auto-image-base'
+		LDCXXSHARED='$(CXX) -shared -Wl,--enable-auto-image-base'
+		;;
+	esac
 fi
 AC_MSG_RESULT($LDSHARED)
 LDCXXSHARED=${LDCXXSHARED-$LDSHARED}
@@ -2007,6 +2126,12 @@
 		# when running test_compile.py.
 		LINKFORSHARED='-Wl,-E -N 2048K';;
 	esac
+	case $host in
+	*-*-mingw*)
+		if test x$enable_shared = xyes; then
+			LINKFORSHARED='-Wl,--out-implib=$(LDLIBRARY)'
+		fi;;
+	esac
 fi
 AC_MSG_RESULT($LINKFORSHARED)
 
@@ -2023,6 +2148,12 @@
 	*)
 		CFLAGSFORSHARED='$(CCSHARED)'
 	esac
+	case $host in
+	*-*-mingw*)
+		# TODO mingw may needs CCSHARED when building extension DLLs
+		# but not when building the interpreter DLL.
+		CFLAGSFORSHARED='';;
+	esac
 fi
 AC_MSG_RESULT($CFLAGSFORSHARED)
 
@@ -2055,9 +2186,18 @@
 fi
 
 # check if we need libintl for locale functions
+case $host in
+  *-*-mingw*)
+  dnl Native windows build don't use libintl (see _localemodule.c).
+  dnl Also we don't like setup.py to add "intl" library to the list
+  dnl when build _locale module.
+  ;;
+  *)
 AC_CHECK_LIB(intl, textdomain,
 	AC_DEFINE(WITH_LIBINTL, 1,
 	[Define to 1 if libintl is needed for locale functions.]))
+  ;;
+esac
 
 # checks for system dependent C++ extensions support
 case "$ac_sys_system" in
@@ -2239,6 +2379,13 @@
     AC_DEFINE(WITH_THREAD)
     posix_threads=yes
     THREADOBJ="Python/thread.o"
+elif test "x$ac_cv_ntthread" = xyes
+then
+    AC_DEFINE(WITH_THREAD)
+    posix_threads=no
+    THREADOBJ="Python/thread.o"
+    AC_DEFINE(NT_THREADS, 1,
+	[Define to 1 if you want to use native NT threads])
 else
     if test ! -z "$with_threads" -a -d "$with_threads"
     then LDFLAGS="$LDFLAGS -L$with_threads"
@@ -2694,6 +2841,14 @@
 	fi
 	;;
 	esac
+	case $host in
+	*-*-mingw*)
+	# FIXME: it is good to use portable "$OBJEXT" instead "o" but
+	# python build isn't yet ready to use it (see Makefile.pre.in)
+	#DYNLOADFILE="dynload_win.$OBJEXT"
+	DYNLOADFILE="dynload_win.o"
+	;;
+	esac
 fi
 AC_MSG_RESULT($DYNLOADFILE)
 if test "$DYNLOADFILE" != "dynload_stub.o"
@@ -2706,6 +2861,11 @@
 
 AC_SUBST(MACHDEP_OBJS)
 AC_MSG_CHECKING(MACHDEP_OBJS)
+case $host in
+  *-*-mingw*)
+    extra_machdep_objs="PC/dl_nt.o PC/getpathp.o PC/import_nt.o"
+    ;;
+esac
 if test -z "$MACHDEP_OBJS"
 then
 	MACHDEP_OBJS=$extra_machdep_objs
@@ -2731,6 +2891,17 @@
  sysconf tcgetpgrp tcsetpgrp tempnam timegm times tmpfile tmpnam tmpnam_r \
  truncate uname unsetenv utimes waitpid wait3 wait4 wcscoll _getpty)
 
+dnl NOTE: On windows platform some functions aren't C functions and require
+dnl additional non-standard decoration and may be libraries.
+dnl As example winsock2 functions, although are based on berkeley sockets
+dnl use stdcall convention. Also they require an additional library ws2_32.
+dnl One of those functions is "getpeername" (see list above)
+dnl and can't be detected by script. Now this impact mingw host platforms.
+dnl Since this function is used only by socketmodule, module include
+dnl necessary headers and is linked with requred libs (see setup.py)
+dnl windows exception will be handled in module code.
+dnl FIXME: If you don't like this, write appropriate check here.
+
 # For some functions, having a definition is not sufficient, since
 # we want to take their address.
 AC_MSG_CHECKING(for chroot)
@@ -2790,6 +2961,10 @@
 # address to avoid compiler warnings and potential miscompilations
 # because of the missing prototypes.
 
+case $host in
+  *-*-mingw*) ac_cv_have_size_t_format=no;;
+esac
+
 AC_MSG_CHECKING(for ctermid_r)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #include <stdio.h>
@@ -3122,6 +3297,15 @@
 [ac_cv_buggy_getaddrinfo=yes],
 [ac_cv_buggy_getaddrinfo=yes]))
 fi
+case $host in
+  *-*-mingw*)
+  #FIXME: mingw "w32api" define getaddinfo if WINVER >= 0x501, i.e. XP or greater.
+  #TODO: mingw require additional check.
+  #NOTE: above check is not correct for windows platforms.
+  #  ac_cv_buggy_getaddrinfo=no
+    :
+    ;;
+esac
 
 AC_MSG_RESULT($ac_cv_buggy_getaddrinfo)
 
@@ -3177,19 +3361,33 @@
 
 AC_MSG_CHECKING(for addrinfo)
 AC_CACHE_VAL(ac_cv_struct_addrinfo,
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]], [[struct addrinfo a]])],
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#ifdef HAVE_WINSOCK2_H
+#  include <ws2tcpip.h>
+#else
+#  include <netdb.h>
+#endif]],
+    [[struct addrinfo a]])],
   [ac_cv_struct_addrinfo=yes],
   [ac_cv_struct_addrinfo=no]))
 AC_MSG_RESULT($ac_cv_struct_addrinfo)
 if test $ac_cv_struct_addrinfo = yes; then
-	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo (netdb.h)])
+	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo])
 fi
 
 AC_MSG_CHECKING(for sockaddr_storage)
 AC_CACHE_VAL(ac_cv_struct_sockaddr_storage,
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#		include <sys/types.h>
-#		include <sys/socket.h>]], [[struct sockaddr_storage s]])],
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_WINSOCK2_H
+#include <winsock2.h>
+#endif]],
+    [[struct sockaddr_storage s]])],
   [ac_cv_struct_sockaddr_storage=yes],
   [ac_cv_struct_sockaddr_storage=no]))
 AC_MSG_RESULT($ac_cv_struct_sockaddr_storage)
@@ -3383,11 +3581,16 @@
 
 # check for --with-libm=...
 AC_SUBST(LIBM)
+dnl obsolete style to set libraries for a system
 case $ac_sys_system in
 Darwin) ;;
 BeOS) ;;
 *) LIBM=-lm
 esac
+dnl new style to set libraries for host system
+case $host in
+  *-*-mingw*) LIBM=;;
+esac
 AC_MSG_CHECKING(for --with-libm=STRING)
 AC_ARG_WITH(libm,
             AS_HELP_STRING([--with-libm=STRING], [math library]),
@@ -3421,6 +3624,13 @@
 # **************************************************
 # * Check for various properties of floating point *
 # **************************************************
+case $host in
+  *-*-mingw*)
+    ac_cv_little_endian_double=yes
+    ac_cv_big_endian_double=no
+    ac_cv_mixed_endian_double=no
+  ;;
+esac
 
 AC_MSG_CHECKING(whether C doubles are little-endian IEEE 754 binary64)
 AC_CACHE_VAL(ac_cv_little_endian_double, [
@@ -3504,6 +3714,8 @@
 
 # This inline assembler syntax may also work for suncc and icc,
 # so we try it on all platforms.
+# Note MSVC build use Python/dtoa.c, but I could not find any reason
+# to use this file for GCC(mingw*) builds, so mingw* will use gcc asm :)
 
 AC_MSG_CHECKING(whether we can use gcc inline assembler to get and set x87 control word)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[
@@ -3551,6 +3763,18 @@
 [ac_cv_x87_double_rounding=yes],
 [ac_cv_x87_double_rounding=no])
 CC="$ac_save_cc"
+case $host in
+  *-*-mingw*)
+    ac_cv_file__dev_ptmx=ignore #NOTE: under MSYS environment device exist
+    ac_cv_file__dev_ptc=no
+    ;;
+esac
+
+if test "x$cross_compiling" = xyes; then
+  case $host in
+    *-*-mingw*) ac_cv_x87_double_rounding=yes;;
+  esac
+fi
 AC_MSG_RESULT($ac_cv_x87_double_rounding)
 if test "$ac_cv_x87_double_rounding" = yes
 then
@@ -3568,6 +3792,12 @@
 # On FreeBSD 6.2, it appears that tanh(-0.) returns 0. instead of
 # -0. on some architectures.
 AC_MSG_CHECKING(whether tanh preserves the sign of zero)
+case $host in
+  *-*-mingw*)
+    # Some MSVC runtimes don't preserve zero sign.
+    # On mingw host we will use always replacement function.
+    ac_cv_tanh_preserves_zero_sign=no;;
+esac
 AC_CACHE_VAL(ac_cv_tanh_preserves_zero_sign, [
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <math.h>
@@ -3593,6 +3823,12 @@
 
 AC_CHECK_FUNCS([acosh asinh atanh copysign erf erfc expm1 finite gamma])
 AC_CHECK_FUNCS([hypot lgamma log1p round tgamma])
+dnl NOTE:
+dnl MSVC build PC/pyconfig.h define HAVE_DECL_ISINF but it is useless
+dnl since header define Py_IS_INFINITY as (!_finite(X) && !_isnan(X)).
+dnl Also in pymath.h is commented too how PC/pyconfig.h define isinf.
+dnl For mingw to keep compatibility with MSVC build we will define
+dnl Py_IS_INFINITY in pyport.h.
 AC_CHECK_DECLS([isinf, isnan, isfinite], [], [], [[#include <math.h>]])
 
 LIBS=$LIBS_SAVE
@@ -3602,6 +3838,13 @@
 # the kernel module that provides POSIX semaphores
 # isn't loaded by default, so an attempt to call
 # sem_open results in a 'Signal 12' error.
+if test $ac_cv_func_sem_open = yes; then
+case $host in
+  *-*-mingw*)
+    # GCC 4.4+ (mingw) support posix threads(!)
+    # bug we won't use them on windows platform.
+    ac_cv_posix_semaphores_enabled=no;;
+esac
 AC_MSG_CHECKING(whether POSIX semaphores are enabled)
 AC_CACHE_VAL(ac_cv_posix_semaphores_enabled,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
@@ -3627,6 +3870,9 @@
 [ac_cv_posix_semaphores_enabled=yes])
 )
 AC_MSG_RESULT($ac_cv_posix_semaphores_enabled)
+else
+   ac_cv_posix_semaphores_enabled=no
+fi
 if test $ac_cv_posix_semaphores_enabled = no
 then
   AC_DEFINE(POSIX_SEMAPHORES_NOT_ENABLED, 1,
@@ -3635,6 +3881,16 @@
 
 # Multiprocessing check for broken sem_getvalue
 AC_MSG_CHECKING(for broken sem_getvalue)
+case $host in
+  *-*-mingw*)
+    # GCC(mingw) 4.4+ require and use posix threads(pthreads-w32)
+    # Also system may contain installed pthreads-w32.
+    # NOTE the test case below don't work for pthreads-w32:
+    # - SEM_FAILED is not defined;
+    # - sem_open is stub;
+    # - sem_getvalue work(!).
+    ac_cv_broken_sem_getvalue=no;;
+esac
 AC_CACHE_VAL(ac_cv_broken_sem_getvalue,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <unistd.h>
@@ -3720,6 +3976,9 @@
 then
   # check whether wchar_t is signed or not
   AC_MSG_CHECKING(whether wchar_t is signed)
+  case $host in
+    *-*-mingw*) ac_cv_wchar_t_signed=no;;
+  esac
   AC_CACHE_VAL(ac_cv_wchar_t_signed, [
   AC_RUN_IFELSE([AC_LANG_SOURCE([[
   #include <wchar.h>
@@ -4171,106 +4430,47 @@
   AC_MSG_RESULT(no)
 fi
 
-if test "$have_long_long" = yes
-then
-  AC_MSG_CHECKING(for %lld and %llu printf() format support)
-  AC_CACHE_VAL(ac_cv_have_long_long_format,
-  AC_RUN_IFELSE([AC_LANG_SOURCE([[[
-  #include <stdio.h>
-  #include <stddef.h>
-  #include <string.h>
+#AC_MSG_CHECKING(for %zd printf() format support)
+#AC_TRY_RUN([#include <stdio.h>
+##include <stddef.h>
+##include <string.h>
+#
+##ifdef HAVE_SYS_TYPES_H
+##include <sys/types.h>
+##endif
+#
+##ifdef HAVE_SSIZE_T
+#typedef ssize_t Py_ssize_t;
+##elif SIZEOF_VOID_P == SIZEOF_LONG
+#typedef long Py_ssize_t;
+##else
+#typedef int Py_ssize_t;
+##endif
+#
+#int main()
+#{
+#    char buffer[256];
+#
+#    if(sprintf(buffer, "%zd", (size_t)123) < 0)
+#       	return 1;
+#
+#    if (strcmp(buffer, "123"))
+#	return 1;
+#
+#    if (sprintf(buffer, "%zd", (Py_ssize_t)-123) < 0)
+#       	return 1;
+#
+#    if (strcmp(buffer, "-123"))
+#	return 1;
+#
+#    return 0;
+#}],
+#[AC_MSG_RESULT(yes)
+# AC_DEFINE(PY_FORMAT_SIZE_T, "z", [Define to printf format modifier for Py_ssize_t])],
+# AC_MSG_RESULT(no))
 
-  #ifdef HAVE_SYS_TYPES_H
-  #include <sys/types.h>
-  #endif
-
-  int main()
-  {
-      char buffer[256];
-
-      if (sprintf(buffer, "%lld", (long long)123) < 0)
-          return 1;
-      if (strcmp(buffer, "123"))
-          return 1;
-
-      if (sprintf(buffer, "%lld", (long long)-123) < 0)
-          return 1;
-      if (strcmp(buffer, "-123"))
-          return 1;
-
-      if (sprintf(buffer, "%llu", (unsigned long long)123) < 0)
-          return 1;
-      if (strcmp(buffer, "123"))
-          return 1;
-
-      return 0;
-  }
-  ]]])],
-  [ac_cv_have_long_long_format=yes],
-  [ac_cv_have_long_long_format=no],
-  [ac_cv_have_long_long_format=no])
-  )
-  AC_MSG_RESULT($ac_cv_have_long_long_format)
-fi
-
-if test "$ac_cv_have_long_long_format" = yes
-then
-  AC_DEFINE(PY_FORMAT_LONG_LONG, "ll",
-  [Define to printf format modifier for long long type])
-fi
-
-if test $ac_sys_system = Darwin
-then
-	LIBS="$LIBS -framework CoreFoundation"
-fi
-
-
-AC_CACHE_CHECK([for %zd printf() format support], ac_cv_have_size_t_format, [dnl
-AC_RUN_IFELSE([AC_LANG_SOURCE([[
-#include <stdio.h>
-#include <stddef.h>
-#include <string.h>
-
-#ifdef HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#ifdef HAVE_SSIZE_T
-typedef ssize_t Py_ssize_t;
-#elif SIZEOF_VOID_P == SIZEOF_LONG
-typedef long Py_ssize_t;
-#else
-typedef int Py_ssize_t;
-#endif
-
-int main()
-{
-    char buffer[256];
-
-    if(sprintf(buffer, "%zd", (size_t)123) < 0)
-       	return 1;
-
-    if (strcmp(buffer, "123"))
-	return 1;
-
-    if (sprintf(buffer, "%zd", (Py_ssize_t)-123) < 0)
-       	return 1;
-
-    if (strcmp(buffer, "-123"))
-	return 1;
-
-    return 0;
-}
-]])],
-[ac_cv_have_size_t_format=yes],
-[ac_cv_have_size_t_format=no],
-[ac_cv_have_size_t_format="cross -- assuming yes"
-])])
-if test "$ac_cv_have_size_t_format" != no ; then
-  AC_DEFINE(PY_FORMAT_SIZE_T, "z",
-  [Define to printf format modifier for Py_ssize_t])
-fi
-
+dnl NOTE: check is incorrect for win host systems, i.e. mingw and etc.,
+dnl but on those systems socklen_t is defined in ws2tcpip.h as int ;)
 AC_CHECK_TYPE(socklen_t,,
   AC_DEFINE(socklen_t,int,
             [Define to `int' if <sys/socket.h> does not define.]),[
@@ -4295,8 +4495,39 @@
   THREADHEADERS="$THREADHEADERS \$(srcdir)/$h"
 done
 
+# FIXME: in cross-compilation env. (mingw on linux) how to select correct compiler ?
+# The current py-code will created modules with .so suffix and environment
+# variable setting SO=$(SO) don't help
+# see output of: python setup.py build --help-compiler
+AC_SUBST(PYMOD_BUILDOPT)
+case $host in
+  *-*-mingw*) PYMOD_BUILDOPT="--compiler mingw32";;
+esac
+
+dnl Objects for python and modules
+# Python interpreter main program for frozen scripts
+AC_SUBST(PYTHON_OBJS_FROZENMAIN)
+PYTHON_OBJS_FROZENMAIN="Python/frozenmain.o"
+# MODULE_GETPATH - default sys.path calculations
+AC_SUBST(MODULE_GETPATH)
+MODULE_GETPATH=Modules/getpath.o
+case $host in
+  *-*-mingw*)
+    dnl "PC" is project sub-directory and we has to prepend user defined flags
+    CPPFLAGS="-I\$(srcdir)/Python -I\$(srcdir)/PC $CPPFLAGS"
+
+    # FIXME: why windows builds don't use PC/frozen_dllmain.o ?
+    PYTHON_OBJS_FROZENMAIN=""
+    # default sys.path calculations for windows platforms
+    MODULE_GETPATH=PC/getpathp.o
+    ;;
+esac
+
 AC_SUBST(SRCDIRS)
 SRCDIRS="Parser Grammar Objects Python Modules Mac"
+case $host in
+  *-*-mingw*) SRCDIRS="$SRCDIRS PC";;
+esac
 AC_MSG_CHECKING(for build directories)
 for dir in $SRCDIRS; do
     if test ! -d $dir; then
Index: setup.py
===================================================================
--- setup.py	(revisión: 29)
+++ setup.py	(copia de trabajo)
@@ -17,8 +17,7 @@
 from distutils.command.install_lib import install_lib
 from distutils.spawn import find_executable
 
-# Were we compiled --with-pydebug or with #define Py_DEBUG?
-COMPILED_WITH_PYDEBUG = hasattr(sys, 'gettotalrefcount')
+COMPILED_WITH_PYDEBUG = ('--with-pydebug' in sysconfig.get_config_var("CONFIG_ARGS"))
 
 # This global variable is used to hold the list of modules to be disabled.
 disabled_module_list = []
@@ -165,7 +164,7 @@
         # with Modules/ and adding Python's include directory to the path.
         (srcdir,) = sysconfig.get_config_vars('srcdir')
         if not srcdir:
-            # Maybe running on Windows but not using CYGWIN?
+            # Maybe running on Windows but not using posix build?
             raise ValueError("No source directory; cannot proceed.")
         srcdir = os.path.abspath(srcdir)
         moddirlist = [os.path.join(srcdir, 'Modules')]
@@ -232,8 +231,38 @@
         if compiler is not None:
             (ccshared,cflags) = sysconfig.get_config_vars('CCSHARED','CFLAGS')
             args['compiler_so'] = compiler + ' ' + ccshared + ' ' + cflags
+
+        # FIXME: Is next correct ?
+        # To link modules we need LDSHARED passed to setup.py otherwise
+        # distutils will use linker from build system if cross-compiling.
+        linker_so = os.environ.get('LDSHARED')
+        if linker_so is not None:
+            args['linker_so'] = linker_so
+
         self.compiler.set_executables(**args)
 
+        if host_platform in ['mingw', 'win32']:
+            # FIXME: best way to pass just build python library to the modules
+            self.compiler.library_dirs.insert(0, '.')
+            data = open('pyconfig.h').read()
+            m = re.search(r"#s*define\s+Py_DEBUG\s+1\s*", data)
+            if m is not None:
+                self.compiler.libraries.append("python" + str(sysconfig.get_config_var('VERSION')) + "_d")
+            else:
+                self.compiler.libraries.append("python" + str(sysconfig.get_config_var('VERSION')))
+
+        if host_platform in ['mingw', 'win32']:
+            # NOTE: See comment for SHLIBS in configure.in .
+            # Although it look obsolete since setup.py add module
+            # required libraries we will pass list too.
+            # As example this will allow us to propage static
+            # libraries like mingwex to modules.
+            for lib in sysconfig.get_config_var('SHLIBS').split():
+                if lib.startswith('-l'):
+                    self.compiler.libraries.append(lib[2:])
+                else:
+                    self.compiler.libraries.append(lib)
+
         build_ext.build_extensions(self)
 
         longest = max([len(e.name) for e in self.extensions])
@@ -304,13 +333,15 @@
             self.announce('WARNING: skipping import check for Cygwin-based "%s"'
                 % ext.name)
             return
+        if os.environ.get('CROSS_COMPILE_TARGET') == 'yes':
+            return
         ext_filename = os.path.join(
             self.build_lib,
             self.get_ext_filename(self.get_ext_fullname(ext.name)))
         try:
             imp.load_dynamic(ext.name, ext_filename)
         except ImportError, why:
-            self.failed.append(ext.name)
+            if os.environ.get('CROSS_COMPILE_TARGET') != "yes":
             self.announce('*** WARNING: renaming "%s" since importing it'
                           ' failed: %s' % (ext.name, why), level=3)
             assert not self.inplace
@@ -331,6 +362,10 @@
                     os.remove(filename)
             except AttributeError:
                 self.announce('unable to remove files (ignored)')
+            else:
+                self.announce('WARNING: "%s" failed importing, but we leave it '
+                              'because we are cross-compiling' %
+                              ext.name)
         except:
             exc_type, why, tb = sys.exc_info()
             self.announce('*** WARNING: importing extension "%s" '
@@ -413,6 +448,8 @@
             # (PYTHONFRAMEWORK is set) to avoid # linking problems when
             # building a framework with different architectures than
             # the one that is currently installed (issue #7473)
+            # NOTE: revision 25103:[ #420565 ] add search in sys.prefix
+            # before current source tree !?!?!?! No comment!
             add_dir_to_list(self.compiler.library_dirs,
                             sysconfig.get_config_var("LIBDIR"))
             add_dir_to_list(self.compiler.include_dirs,
@@ -458,6 +495,7 @@
             #   NOTE: using shlex.split would technically be more correct, but
             # also gives a bootstrap problem. Let's hope nobody uses directories
             # with whitespace in the name to store libraries.
+            # FIXME: Why LDFLAGS again ?
             cflags, ldflags = sysconfig.get_config_vars(
                     'CFLAGS', 'LDFLAGS')
             for item in cflags.split():
@@ -514,14 +552,20 @@
         # heapq
         exts.append( Extension("_heapq", ["_heapqmodule.c"]) )
         # operator.add() and similar goodies
-        exts.append( Extension('operator', ['operator.c']) )
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension('operator', ['operator.c']) )
         # Python 3.1 _io library
         exts.append( Extension("_io",
             ["_io/bufferedio.c", "_io/bytesio.c", "_io/fileio.c",
              "_io/iobase.c", "_io/_iomodule.c", "_io/stringio.c", "_io/textio.c"],
-             depends=["_io/_iomodule.h"], include_dirs=["Modules/_io"]))
+             depends=["_io/_iomodule.h"], include_dirs=[os.path.join(srcdir,"Modules/_io")]))
         # _functools
-        exts.append( Extension("_functools", ["_functoolsmodule.c"]) )
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension("_functools", ["_functoolsmodule.c"]) )
         # _json speedups
         exts.append( Extension("_json", ["_json.c"]) )
         # Python C API test module
@@ -548,7 +592,10 @@
             locale_extra_link_args = []
 
 
-        exts.append( Extension('_locale', ['_localemodule.c'],
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension('_locale', ['_localemodule.c'],
                                libraries=locale_libs,
                                extra_link_args=locale_extra_link_args) )
 
@@ -557,24 +604,35 @@
         # supported...)
 
         # fcntl(2) and ioctl(2)
-        libs = []
-        if (config_h_vars.get('FLOCK_NEEDS_LIBBSD', False)):
-            # May be necessary on AIX for flock function
-            libs = ['bsd']
-        exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
-        # pwd(3)
-        exts.append( Extension('pwd', ['pwdmodule.c']) )
-        # grp(3)
-        exts.append( Extension('grp', ['grpmodule.c']) )
-        # spwd, shadow passwords
-        if (config_h_vars.get('HAVE_GETSPNAM', False) or
-                config_h_vars.get('HAVE_GETSPENT', False)):
-            exts.append( Extension('spwd', ['spwdmodule.c']) )
+        if host_platform not in ['mingw', 'win32']:
+            libs = []
+            if (config_h_vars.get('FLOCK_NEEDS_LIBBSD', False)):
+                # May be necessary on AIX for flock function
+                libs = ['bsd']
+            exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
         else:
-            missing.append('spwd')
+            missing.append('fcntl')
+        if host_platform not in ['mingw', 'win32']:
+            # pwd(3)
+            exts.append( Extension('pwd', ['pwdmodule.c']) )
+            # grp(3)
+            exts.append( Extension('grp', ['grpmodule.c']) )
+            # spwd, shadow passwords
+            if (config_h_vars.get('HAVE_GETSPNAM', False) or
+                    config_h_vars.get('HAVE_GETSPENT', False)):
+                exts.append( Extension('spwd', ['spwdmodule.c']) )
+            else:
+                missing.append('spwd')
+        else:
+            missing.extend(['pwd', 'grp', 'spwd'])
 
         # select(2); not on ancient System V
-        exts.append( Extension('select', ['selectmodule.c']) )
+        if host_platform in ['mingw', 'win32']:
+            select_libs = ['ws2_32']
+        else:
+            select_libs = []
+        exts.append( Extension('select', ['selectmodule.c'],
+                               libraries=select_libs) )
 
         # Fred Drake's interface to the Python parser
         exts.append( Extension('parser', ['parsermodule.c']) )
@@ -590,8 +648,11 @@
             missing.append('mmap')
 
         # Lance Ellinghaus's syslog module
-        # syslog daemon interface
-        exts.append( Extension('syslog', ['syslogmodule.c']) )
+        if host_platform not in ['mingw', 'win32']:
+            # syslog daemon interface
+            exts.append( Extension('syslog', ['syslogmodule.c']) )
+        else:
+            missing.append('syslog')
 
         # George Neville-Neil's timing module:
         # Deprecated in PEP 4 http://www.python.org/peps/pep-0004.html
@@ -688,18 +749,25 @@
             missing.append('readline')
 
         # crypt module.
-
-        if self.compiler.find_library_file(lib_dirs, 'crypt'):
-            libs = ['crypt']
+        if host_platform not in ['mingw', 'win32']:
+            if self.compiler.find_library_file(lib_dirs, 'crypt'):
+                libs = ['crypt']
+            else:
+                libs = []
+            exts.append( Extension('crypt', ['cryptmodule.c'], libraries=libs) )
         else:
-            libs = []
-        exts.append( Extension('crypt', ['cryptmodule.c'], libraries=libs) )
+            missing.append('crypt')
 
         # CSV files
         exts.append( Extension('_csv', ['_csv.c']) )
 
         # socket(2)
+        if host_platform in ['mingw', 'win32']:
+            socket_libs = ['ws2_32']
+        else:
+            socket_libs = []
         exts.append( Extension('_socket', ['socketmodule.c'],
+                               libraries=socket_libs,
                                depends = ['socketmodule.h']) )
         # Detect SSL support for the socket module (via _ssl)
         search_for_ssl_incs_in = [
@@ -721,10 +789,13 @@
 
         if (ssl_incs is not None and
             ssl_libs is not None):
+            _ssl_libs = ['ssl', 'crypto']
+            if host_platform in ['mingw', 'win32']:
+                _ssl_libs.append('ws2_32')
             exts.append( Extension('_ssl', ['_ssl.c'],
                                    include_dirs = ssl_incs,
                                    library_dirs = ssl_libs,
-                                   libraries = ['ssl', 'crypto'],
+                                   libraries = _ssl_libs,
                                    depends = ['socketmodule.h']), )
         else:
             missing.append('_ssl')
@@ -754,20 +825,23 @@
         min_openssl_ver = 0x00907000
         have_any_openssl = ssl_incs is not None and ssl_libs is not None
         have_usable_openssl = (have_any_openssl and
-                               openssl_ver >= min_openssl_ver)
+                               openssl_ver >= min_openssl_ver and False)
 
         if have_any_openssl:
             if have_usable_openssl:
                 # The _hashlib module wraps optimized implementations
                 # of hash functions from the OpenSSL library.
+                # NOTE: _hashlib require only OpenSSL crypto library !
                 exts.append( Extension('_hashlib', ['_hashopenssl.c'],
                                        include_dirs = ssl_incs,
                                        library_dirs = ssl_libs,
-                                       libraries = ['ssl', 'crypto']) )
+                                       libraries = ['crypto']) )
             else:
                 print ("warning: openssl 0x%08x is too old for _hashlib" %
                        openssl_ver)
                 missing.append('_hashlib')
+        # NOTE: MSVC build alwais include _md5 and _sha modules
+        # as build-in modules
         if COMPILED_WITH_PYDEBUG or not have_usable_openssl:
             # The _sha module implements the SHA1 hash algorithm.
             exts.append( Extension('_sha', ['shamodule.c']) )
@@ -779,7 +853,7 @@
                             depends = ['md5.h']) )
 
         min_sha2_openssl_ver = 0x00908000
-        if COMPILED_WITH_PYDEBUG or openssl_ver < min_sha2_openssl_ver:
+        if COMPILED_WITH_PYDEBUG or (True or openssl_ver < min_sha2_openssl_ver):
             # OpenSSL doesn't do these until 0.9.8 so we'll bring our own hash
             exts.append( Extension('_sha256', ['sha256module.c']) )
             exts.append( Extension('_sha512', ['sha512module.c']) )
@@ -803,6 +877,29 @@
         min_db_ver = (4, 1)
         db_setup_debug = False   # verbose debug prints from this script?
 
+        # Modules with some Windows dependencies:
+        if host_platform in ['mingw', 'win32']:
+            srcdir = sysconfig.get_config_var('srcdir')
+            pc_srcdir = os.path.abspath(os.path.join(srcdir, 'PC'))
+
+            exts.append( Extension('msvcrt', [os.path.join(pc_srcdir, p)
+                for p in ['msvcrtmodule.c']]) )
+
+            exts.append( Extension('_msi', [os.path.join(pc_srcdir, p)
+                for p in ['_msi.c']]) )
+
+            exts.append( Extension('_subprocess', [os.path.join(pc_srcdir, p)
+                for p in ['_subprocess.c']]) )
+
+            # On win32 host(mingw build in MSYS environment) show that site.py
+            # fail to load if some modules are not build-in:
+            #exts.append( Extension('_winreg', [os.path.join(pc_srcdir, p)
+            #    for p in ['_winreg.c']]) )
+
+            exts.append( Extension('winsound', [os.path.join(pc_srcdir, p)
+                for p in ['winsound.c']],
+                libraries=['winmm']) )
+
         def allow_db_ver(db_ver):
             """Returns a boolean if the given BerkeleyDB version is acceptable.
 
@@ -1211,7 +1308,8 @@
                 missing.append('dbm')
 
         # Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:
-        if ('gdbm' in dbm_order and
+        if (host_platform not in ['mingw', 'win32'] and
+            'gdbm' in dbm_order and
             self.compiler.find_library_file(lib_dirs, 'gdbm')):
             exts.append( Extension('gdbm', ['gdbmmodule.c'],
                                    libraries = ['gdbm'] ) )
@@ -1467,7 +1565,9 @@
                 multiprocessing_srcs.append('_multiprocessing/semaphore.c')
 
         if sysconfig.get_config_var('WITH_THREAD'):
+            #FIXME: why above set libraries aren't used ?
             exts.append ( Extension('_multiprocessing', multiprocessing_srcs,
+                                    libraries=libraries,
                                     define_macros=macros.items(),
                                     include_dirs=["Modules/_multiprocessing"]))
         else:
@@ -1508,6 +1608,7 @@
         if platform == 'darwin' and ("--disable-toolbox-glue" not in
                 sysconfig.get_config_var("CONFIG_ARGS")):
 
+            #FIXME: next fail in cross-compilation environment
             if int(os.uname()[2].split('.')[0]) >= 8:
                 # We're on Mac OS X 10.4 or later, the compiler should
                 # support '-Wno-deprecated-declarations'. This will
@@ -1754,6 +1855,9 @@
         if platform == 'sunos5':
             include_dirs.append('/usr/openwin/include')
             added_lib_dirs.append('/usr/openwin/lib')
+        elif host_platform in ['mingw', 'win32']:
+            # mingw&win32 don't use X11 headers and libraries
+            pass
         elif os.path.exists('/usr/X11R6/include'):
             include_dirs.append('/usr/X11R6/include')
             added_lib_dirs.append('/usr/X11R6/lib64')
@@ -1841,6 +1945,38 @@
         return True
 
     def configure_ctypes(self, ext):
+        if host_platform in ['mingw', 'win32']:
+            # win32 platform use own sources and includes
+            # from Modules/_ctypes/libffi_msvc/
+            srcdir = sysconfig.get_config_var('srcdir')
+
+            ffi_srcdir = os.path.abspath(os.path.join(srcdir, 'Modules',
+                                         '_ctypes'))
+            sources = [os.path.join(ffi_srcdir, p)
+                for p in ['malloc_closure.c',
+                         ]]
+            ext.sources.extend(sources)
+
+            ffi_srcdir = os.path.abspath(os.path.join(srcdir, 'Modules',
+                                         '_ctypes', 'libffi_msvc'))
+            #FIXME: _ctypes/libffi_msvc/win64.asm ?
+            sources = [os.path.join(ffi_srcdir, p)
+                for p in ['ffi.c',
+                          'prep_cif.c',
+                          'win32.S',
+                         ]]
+            # NOTE: issue2942 don't resolve problem with assembler code.
+            # It seems to me that python refuse to build an extension
+            # if exist a source with unknown suffix.
+            self.compiler.src_extensions.append('.s')
+            self.compiler.src_extensions.append('.S')
+            ext.include_dirs.append(ffi_srcdir)
+            ext.sources.extend(sources)
+            ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
+            #AdditionalOptions="/EXPORT:DllGetClassObject,PRIVATE /EXPORT:DllCanUnloadNow,PRIVATE"
+            ext.export_symbols.extend(['DllGetClassObject PRIVATE',
+                                       'DllCanUnloadNow PRIVATE'])
+            return True
         if not self.use_system_libffi:
             if sys.platform == 'darwin':
                 return self.configure_ctypes_darwin(ext)
@@ -1860,7 +1996,7 @@
                                          ffi_configfile):
                 from distutils.dir_util import mkpath
                 mkpath(ffi_builddir)
-                config_args = []
+                config_args =  sysconfig.get_config_var("CONFIG_ARGS").split(" ")
 
                 # Pass empty CFLAGS because we'll just append the resulting
                 # CFLAGS to Python's; -g or -O2 is to be avoided.
@@ -1888,6 +2024,11 @@
                                fficonfig['ffi_sources'])
             ext.include_dirs.extend(include_dirs)
             ext.extra_compile_args.extend(extra_compile_args)
+            if host_platform in ['mingw', 'win32']:
+                ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
+                #AdditionalOptions="/EXPORT:DllGetClassObject,PRIVATE /EXPORT:DllCanUnloadNow,PRIVATE"
+                ext.export_symbols.extend(['DllGetClassObject PRIVATE',
+                                           'DllCanUnloadNow PRIVATE'])
         return True
 
     def detect_ctypes(self, inc_dirs, lib_dirs):
@@ -1931,7 +2072,12 @@
                         libraries=[],
                         sources=sources,
                         depends=depends)
+        if host_platform in ['mingw', 'win32']:
+            ctypes_test_libs = ['oleaut32']
+        else:
+            ctypes_test_libs = []
         ext_test = Extension('_ctypes_test',
+                             libraries=ctypes_test_libs,
                              sources=['_ctypes/_ctypes_test.c'])
         self.extensions.extend([ext, ext_test])
 
Index: Objects/fileobject.c
===================================================================
--- Objects/fileobject.c	(revisión: 29)
+++ Objects/fileobject.c	(copia de trabajo)
@@ -9,9 +9,17 @@
 #endif /* HAVE_SYS_TYPES_H */
 
 #ifdef MS_WINDOWS
+#if !defined(__MINGW32__)
+/* avoid 'warning: "fileno" redefined' */
 #define fileno _fileno
+#endif
 /* can simulate truncate with Win32 API functions; see file_truncate */
+#ifndef HAVE_FTRUNCATE
+/* NOTE: autotool based build check and set it
+   FIXME: why isn't defined in PC/pyconfig.h ?
+ */
 #define HAVE_FTRUNCATE
+#endif
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
Index: Objects/stringlib/localeutil.h
===================================================================
--- Objects/stringlib/localeutil.h	(revisión: 29)
+++ Objects/stringlib/localeutil.h	(copia de trabajo)
@@ -202,10 +202,8 @@
                                   Py_ssize_t n_digits,
                                   Py_ssize_t min_width)
 {
-        struct lconv *locale_data = localeconv();
-        const char *grouping = locale_data->grouping;
-        const char *thousands_sep = locale_data->thousands_sep;
-
+        const char *grouping = 3;
+        const char *thousands_sep = ",";
         return _Py_InsertThousandsGrouping(buffer, n_buffer, digits, n_digits,
                                            min_width, grouping, thousands_sep);
 }
Index: Objects/stringlib/formatter.h
===================================================================
--- Objects/stringlib/formatter.h	(revisión: 29)
+++ Objects/stringlib/formatter.h	(copia de trabajo)
@@ -639,13 +639,7 @@
 get_locale_info(int type, LocaleInfo *locale_info)
 {
     switch (type) {
-    case LT_CURRENT_LOCALE: {
-        struct lconv *locale_data = localeconv();
-        locale_info->decimal_point = locale_data->decimal_point;
-        locale_info->thousands_sep = locale_data->thousands_sep;
-        locale_info->grouping = locale_data->grouping;
-        break;
-    }
+    case LT_CURRENT_LOCALE:
     case LT_DEFAULT_LOCALE:
         locale_info->decimal_point = ".";
         locale_info->thousands_sep = ",";
Index: Objects/longobject.c
===================================================================
--- Objects/longobject.c	(revisión: 29)
+++ Objects/longobject.c	(copia de trabajo)
@@ -813,13 +813,18 @@
     return (void *)x;
 }
 
+#ifdef ANDROID
+    #define IS_LITTLE_ENDIAN (int)*(unsigned char*)&one
+#endif
+
 #ifdef HAVE_LONG_LONG
 
 /* Initial PY_LONG_LONG support by Chris Herborth (chrish@qnx.com), later
  * rewritten to use the newer PyLong_{As,From}ByteArray API.
  */
-
-#define IS_LITTLE_ENDIAN (int)*(unsigned char*)&one
+#ifndef ANDROID
+    #define IS_LITTLE_ENDIAN (int)*(unsigned char*)&one
+#endif
 #define PY_ABS_LLONG_MIN (0-(unsigned PY_LONG_LONG)PY_LLONG_MIN)
 
 /* Create a new long int object from a C PY_LONG_LONG int. */
@@ -891,7 +896,7 @@
     }
     return (PyObject *)v;
 }
-
+#ifndef ANDROID
 /* Create a new long int object from a C Py_ssize_t. */
 
 PyObject *
@@ -913,6 +918,7 @@
     return _PyLong_FromByteArray((unsigned char *)&bytes,
                                  SIZEOF_SIZE_T, IS_LITTLE_ENDIAN, 0);
 }
+#endif
 
 /* Get a C PY_LONG_LONG int from a long int object.
    Return -1 and set an error if overflow occurs. */
@@ -1121,7 +1127,32 @@
     }
     return res;
 }
+#ifdef ANDROID
+/* Create a new long int object from a C Py_ssize_t. */
 
+PyObject *
+PyLong_FromSsize_t(Py_ssize_t ival)
+{
+	Py_ssize_t bytes = ival;
+	int one = 1;
+	return _PyLong_FromByteArray(
+			(unsigned char *)&bytes,
+			SIZEOF_SIZE_T, IS_LITTLE_ENDIAN, 1);
+}
+
+/* Create a new long int object from a C size_t. */
+
+PyObject *
+PyLong_FromSize_t(size_t ival)
+{
+	size_t bytes = ival;
+	int one = 1;
+	return _PyLong_FromByteArray(
+			(unsigned char *)&bytes,
+			SIZEOF_SIZE_T, IS_LITTLE_ENDIAN, 0);
+}
+#endif
+
 #undef IS_LITTLE_ENDIAN
 
 #endif /* HAVE_LONG_LONG */
Index: PC/os2vacpp/config.c
===================================================================
--- PC/os2vacpp/config.c	(revisión: 29)
+++ PC/os2vacpp/config.c	(copia de trabajo)
@@ -59,7 +59,7 @@
 //        {"imageop", initimageop},
         {"math", initmath},
         {"md5", initmd5},
-#if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__)
+#if defined(MS_WINDOWS) || defined(__BORLANDC__) || defined(__WATCOMC__) || defined(__MINGW32__)
         {"nt", initnt}, /* Use the NT os functions, not posix */
 #else
 #if defined(PYOS_OS2)
Index: PC/pyconfig.h
===================================================================
--- PC/pyconfig.h	(revisión: 29)
+++ PC/pyconfig.h	(copia de trabajo)
@@ -710,7 +710,7 @@
 /* #undef HAVE_THREAD_H */
 
 /* Define if you have the <unistd.h> header file.  */
-/* #define HAVE_UNISTD_H 1 */
+#define HAVE_UNISTD_H 1
 
 /* Define if you have the <utime.h> header file.  */
 /* #define HAVE_UTIME_H 1 */
Index: PC/msvcrtmodule.c
===================================================================
--- PC/msvcrtmodule.c	(revisión: 29)
+++ PC/msvcrtmodule.c	(copia de trabajo)
@@ -22,6 +22,31 @@
 #include <conio.h>
 #include <sys/locking.h>
 
+#if defined(__MINGW32__)
+#if __MSVCRT_VERSION__ >= 0x0700
+# define _WCONIO_DEFINED
+/* NOTE: Up to version ?.?? mingw don't define functions
+ * listed below. Also it require module to be linked with
+ * ms-vcrt at least verion 7.
+ * To build with different runtimes see:
+ *  http://www.mingw.org/wiki/HOWTO_Use_the_GCC_specs_file
+ *
+ * Also note that NT5.1(XP), shiped with msvcrt version 7.0,
+ * contain all those functions, but library name is msvcrt.dll.
+ * So if you like module to run on w2k as is you must define
+ * appropriate __MSVCRT_VERSION__ .
+ * If you like those functions even on w2k you must link
+ * with appropriate runtime and to pack it in distributions.
+ * This is what MSVC build do - it is build and packed
+ * with version 9.0 of Microsoft C-runtime.
+ */
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_getwch (void);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_getwche (void);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_putwch (wchar_t);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_ungetwch(wint_t);
+#endif /* __MSVCRT_VERSION__ >= 0x0700 */
+#endif
+
 #ifdef _MSC_VER
 #if _MSC_VER >= 1500 && _MSC_VER < 1600
 #include <crtassem.h>
@@ -346,6 +371,7 @@
     if (!PyArg_ParseTuple(args, "u:ungetwch", &ch))
         return NULL;
 
+    /* FIXME: why _ungetch is called instead _ungetwch */
     if (_ungetch(ch) == EOF)
         return PyErr_SetFromErrno(PyExc_IOError);
     Py_INCREF(Py_None);
Index: PC/_winreg.c
===================================================================
--- PC/_winreg.c	(revisión: 29)
+++ PC/_winreg.c	(copia de trabajo)
@@ -17,6 +17,18 @@
 #include "malloc.h" /* for alloca */
 #include "windows.h"
 
+#if defined(__MINGW32__)
+_CRTIMP size_t __cdecl __MINGW_NOTHROW _mbstrlen(const char *s);
+#endif
+
+#if !defined(REG_LEGAL_CHANGE_FILTER)
+#define REG_LEGAL_CHANGE_FILTER                 \
+                (REG_NOTIFY_CHANGE_NAME          |\
+                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
+                 REG_NOTIFY_CHANGE_LAST_SET      |\
+                 REG_NOTIFY_CHANGE_SECURITY)
+#endif
+
 static BOOL PyHKEY_AsHKEY(PyObject *ob, HKEY *pRes, BOOL bNoneOK);
 static PyObject *PyHKEY_FromHKEY(HKEY h);
 static BOOL PyHKEY_Close(PyObject *obHandle);
@@ -1087,6 +1099,15 @@
 static PyObject *
 PyDeleteKeyEx(PyObject *self, PyObject *args)
 {
+#ifndef KEY_WOW64_64KEY
+/* KEY_WOW64_64KEY is defined for _WIN32_WINNT >= 0x0502,
+  i.e. Windows Server 2003 with SP1, Windows XP with SP2
+  and not supported on w2k
+ */
+    PyErr_SetString(PyExc_NotImplementedError,
+                    "not implemented on this platform");
+    return NULL;
+#else /*def KEY_WOW64_64KEY*/
     HKEY hKey;
     PyObject *obKey;
     HMODULE hMod;
@@ -1122,6 +1143,7 @@
         return PyErr_SetFromWindowsErrWithFunction(rc, "RegDeleteKeyEx");
     Py_INCREF(Py_None);
     return Py_None;
+#endif
 }
 
 static PyObject *
Index: Lib/distutils/cygwinccompiler.py
===================================================================
--- Lib/distutils/cygwinccompiler.py	(revisión: 29)
+++ Lib/distutils/cygwinccompiler.py	(copia de trabajo)
@@ -60,6 +60,18 @@
     """Include the appropriate MSVC runtime library if Python was built
     with MSVC 7.0 or later.
     """
+    # FIXME: next code is from issue870382
+    # MS C-runtime libraries never support backward compatibility.
+    # Linking to a different library without to specify correct runtime
+    # version for the headers will link renamed functions to msvcrt.
+    # See issue3308: this piece of code is python problem even
+    # with correct w32api headers.
+    # Issue: for MSVC compiler we can get the version and from version
+    # to determine mcvcrt as code below. But what about if python is
+    # build with GCC compiler?
+    # Output of sys.version is information for python build on first
+    # line, on the next line is information for the compiler and the
+    # output lack information for the C-runtime.
     msc_pos = sys.version.find('MSC v.')
     if msc_pos != -1:
         msc_ver = sys.version[msc_pos+6:msc_pos+10]
@@ -77,6 +89,8 @@
             return ['msvcr90']
         else:
             raise ValueError("Unknown MS Compiler version %s " % msc_ver)
+    else:
+        return []
 
 
 class CygwinCCompiler (UnixCCompiler):
@@ -85,6 +99,9 @@
     obj_extension = ".o"
     static_lib_extension = ".a"
     shared_lib_extension = ".dll"
+    # FIXME: dylib_... = ".dll.a" is not enought for binutils
+    # loader on win32 platform !!!
+    dylib_lib_extension = ".dll.a"
     static_lib_format = "lib%s%s"
     shared_lib_format = "%s%s"
     exe_extension = ".exe"
@@ -103,6 +120,10 @@
                 "Compiling may fail because of undefined preprocessor macros."
                 % details)
 
+        # Next line of code is problem for cross-compiled enviroment:
+        # NOTE: GCC cross-compiler is prefixed by the <hostarch>-<hostos>-
+        # and by default binaries are installed in same directory
+        # as native compiler.
         self.gcc_version, self.ld_version, self.dllwrap_version = \
             get_versions()
         self.debug_print(self.compiler_type + ": gcc %s, ld %s, dllwrap %s\n" %
@@ -127,6 +148,9 @@
         else:
             shared_option = "-mdll -static"
 
+        # FIXME:
+        # Hard-code may override unix-compiler settings and isn't
+        # possible to use Makefile variables to pass correct flags !
         # Hard-code GCC because that's what this is all about.
         # XXX optimization, warnings etc. should be customizable.
         self.set_executables(compiler='gcc -mcygwin -O -Wall',
@@ -271,12 +295,20 @@
         if output_dir is None: output_dir = ''
         obj_names = []
         for src_name in source_filenames:
-            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
-            (base, ext) = os.path.splitext (os.path.normcase(src_name))
+            # FIXME: "bogus checks for suffix" - as example the commented
+            # by #BOGUS# code break valid assembler suffix ".S" !
+            #BOGUS## use normcase to make sure '.rc' is really '.rc' and not '.RC'
+            #BOGUS#base, ext = os.path.splitext(os.path.normcase(src_name))
+            base, ext = os.path.splitext (src_name)
+            ext_normcase = os.path.normcase(ext)
+            if ext_normcase in ['.rc','.res']:
+                ext = ext_normcase
             if ext not in (self.src_extensions + ['.rc','.res']):
                 raise UnknownFileError, \
                       "unknown file type '%s' (from '%s')" % \
                       (ext, src_name)
+            base = os.path.splitdrive(base)[1] # Chop off the drive
+            base = base[os.path.isabs(base):]  # If abs, chop off leading /
             if strip_dir:
                 base = os.path.basename (base)
             if ext == '.res' or ext == '.rc':
Index: Lib/distutils/tests/test_build_ext.py
===================================================================
--- Lib/distutils/tests/test_build_ext.py	(revisión: 29)
+++ Lib/distutils/tests/test_build_ext.py	(copia de trabajo)
@@ -60,6 +60,9 @@
         # To further add to the fun, we can't just add library_dirs to the
         # Extension() instance because that doesn't get plumbed through to the
         # final compiler command.
+        #NOTE: [py3k svn r85559] First (uncontroversial) part of issue 9807, barry.warsaw, 2010-10-16 :
+        #- new _fixup_command is bogus, so we will use own work-around
+        #- for mingw the line may contain " or sys.version.find('GCC') >= 0" in addition
         if (sysconfig.get_config_var('Py_ENABLE_SHARED') and
             not sys.platform.startswith('win')):
             runshared = sysconfig.get_config_var('RUNSHARED')
@@ -92,6 +95,11 @@
             sys.stdout = StringIO()
         try:
             cmd.ensure_finalized()
+            #Broken after issue 7712(r78136) : add a temp_cwd context manager to test_support ...
+            #Without current working dir: "...cannot find -lpython27"
+            #NOTE: [py3k svn r85559] First (uncontroversial) part of issue 9807, barry.warsaw, 2010-10-16 :
+            #  new _fixup_command is bogus, so we will use own work-around
+            cmd.library_dirs.insert(0, test_support.SAVEDCWD)
             cmd.run()
         finally:
             sys.stdout = old_stdout
@@ -285,6 +293,12 @@
         # returns wrong result with --inplace
         other_tmp_dir = os.path.realpath(self.mkdtemp())
         old_wd = os.getcwd()
+        #Without current working dir: "...cannot find -lpython27"
+        #NOTE: After issue #7712(r78136) test cannot use old_wd !
+        #cmd.library_dirs.insert(0, old_wd)
+        #NOTE: [py3k svn r85559] First (uncontroversial) part of issue 9807, barry.warsaw, 2010-10-16 :
+        #  new _fixup_command is bogus, so we will use own work-around
+        cmd.library_dirs.insert(0, test_support.SAVEDCWD)
         os.chdir(other_tmp_dir)
         try:
             cmd.inplace = 1
Index: Lib/distutils/tests/test_unixccompiler.py
===================================================================
--- Lib/distutils/tests/test_unixccompiler.py	(revisión: 29)
+++ Lib/distutils/tests/test_unixccompiler.py	(copia de trabajo)
@@ -120,7 +120,7 @@
         def gcv(v):
             return 'xxx'
         sysconfig.get_config_var = gcv
-        self.assertEqual(self.cc.rpath_foo(), '-R/foo')
+        self.assertEqual(self.cc.rpath_foo(), '-blibpath:/foo')
 
 
 def test_suite():
Index: Lib/distutils/tests/test_config_cmd.py
===================================================================
--- Lib/distutils/tests/test_config_cmd.py	(revisión: 29)
+++ Lib/distutils/tests/test_config_cmd.py	(copia de trabajo)
@@ -38,6 +38,7 @@
         self.assertEqual(len(self._logs), numlines+1)
 
     def test_search_cpp(self):
+        # TODO: mingw host ?
         if sys.platform == 'win32':
             return
         pkg_dir, dist = self.create_dist()
Index: Lib/distutils/tests/test_sysconfig.py
===================================================================
--- Lib/distutils/tests/test_sysconfig.py	(revisión: 29)
+++ Lib/distutils/tests/test_sysconfig.py	(copia de trabajo)
@@ -43,9 +43,15 @@
         # This is not much of a test.  We make sure Python.h exists
         # in the directory returned by get_python_inc() but we don't know
         # it is the correct file.
+        #Broken after issue 7712(r78136) : add a temp_cwd context manager to test_support ...
+        #NOTE: Its fail on platforms without root directory support(like windows)
+        #where temp and current working directories may stay on different drivers.
+        old_wd = os.getcwd()
+        os.chdir(SAVEDCWD)
         self.assertTrue(os.path.isdir(inc_dir), inc_dir)
         python_h = os.path.join(inc_dir, "Python.h")
         self.assertTrue(os.path.isfile(python_h), python_h)
+        os.chdir(old_wd)
 
     def test_parse_makefile_base(self):
         self.makefile = test.test_support.TESTFN
Index: Lib/distutils/ccompiler.py
===================================================================
--- Lib/distutils/ccompiler.py	(revisión: 29)
+++ Lib/distutils/ccompiler.py	(copia de trabajo)
@@ -25,8 +25,18 @@
 
     Mainly needed on Unix, so we can plug in the information that
     varies across Unices and is stored in Python's Makefile.
+
+    NOTE (known limitation of python build/install system):
+    In cross-build environment make macros like CC and LDSHARED
+    contain cross-compiler/linker instead of host compiler/linker.
     """
+    posix_build = None
     if compiler.compiler_type == "unix":
+        posix_build = True
+    elif compiler.compiler_type == "mingw32":
+        if sys.version.find('GCC') >= 0:
+            posix_build = True
+    if posix_build == True:
         (cc, cxx, opt, cflags, ccshared, ldshared, so_ext, ar, ar_flags) = \
             _sysconfig.get_config_vars('CC', 'CXX', 'OPT', 'CFLAGS',
                                        'CCSHARED', 'LDSHARED', 'SO', 'AR',
@@ -968,6 +978,8 @@
         osname = os.name
     if platform is None:
         platform = sys.platform
+    if osname == "nt" and sys.version.find('GCC') >= 0:
+        return 'mingw32'
     for pattern, compiler in _default_compilers:
         if re.match(pattern, platform) is not None or \
            re.match(pattern, osname) is not None:
Index: Lib/distutils/unixccompiler.py
===================================================================
--- Lib/distutils/unixccompiler.py	(revisión: 29)
+++ Lib/distutils/unixccompiler.py	(copia de trabajo)
@@ -292,6 +292,8 @@
             return ["+s", "-L" + dir]
         elif sys.platform[:7] == "irix646" or sys.platform[:6] == "osf1V5":
             return ["-rpath", dir]
+        elif sys.platform[:3] == "aix":
+            return "-blibpath:" + dir
         elif self._is_gcc(compiler):
             return "-Wl,-R" + dir
         else:
Index: Lib/distutils/command/build_ext.py
===================================================================
--- Lib/distutils/command/build_ext.py	(revisión: 29)
+++ Lib/distutils/command/build_ext.py	(copia de trabajo)
@@ -19,7 +19,8 @@
 from distutils.util import get_platform
 from distutils import log
 
-if os.name == 'nt':
+# GCC(mingw): os.name is "nt" but build system is posix
+if os.name == 'nt' and sys.version.find('GCC') < 0:
     from distutils.msvccompiler import get_build_version
     MSVC_VERSION = int(get_build_version())
 
@@ -180,7 +181,8 @@
         # for extensions under windows use different directories
         # for Release and Debug builds.
         # also Python's library directory must be appended to library_dirs
-        if os.name == 'nt':
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == 'nt' and sys.version.find('GCC') < 0:
             # the 'libs' directory is for binary installs - we assume that
             # must be the *native* platform.  But we don't really support
             # cross-compiling via a binary install anyway, so we let it go.
@@ -222,7 +224,8 @@
 
         # for extensions under Cygwin and AtheOS Python's library directory must be
         # appended to library_dirs
-        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
+        if (sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos'
+            or (sys.platform == 'win32' and sys.version.find('GCC') >= 0)):
             if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                 # building third party extensions
                 self.library_dirs.append(os.path.join(sys.prefix, "lib",
@@ -700,6 +703,34 @@
         # pyconfig.h that MSVC groks.  The other Windows compilers all seem
         # to need it mentioned explicitly, though, so that's what we do.
         # Append '_d' to the python import library on debug builds.
+
+        # FIXME: What is purpose of code below ?
+        # The posix build system khow requred libraries to build a module.
+        # The libraries are stored in config(Makefile) variables BLDLIBRARY,
+        # MODLIBS and SHLIBS. Note that some variables may contain linker
+        # flags.
+        # NOTE: For now we will check only GCC(mingw) compiler as is clear
+        # that we build for windows platfrom.
+        # The code for GCC(mingw) is not correct but this is distutils
+        # limitation - we has to pass variables to the linker as is
+        # instead only library names.
+        if self.compiler.compiler_type == 'mingw32':
+            from distutils import sysconfig
+            template = "python%s"
+            if self.debug:
+                template = template + '_d'
+            extra = [(template % (sysconfig.get_config_var('VERSION')))]
+            for lib in sysconfig.get_config_var('BLDLIBRARY').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            for lib in sysconfig.get_config_var('MODLIBS').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            for lib in sysconfig.get_config_var('SHLIBS').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            return ext.libraries + extra
+
         if sys.platform == "win32":
             from distutils.msvccompiler import MSVCCompiler
             if not isinstance(self.compiler, MSVCCompiler):
Index: Lib/distutils/sysconfig.py
===================================================================
--- Lib/distutils/sysconfig.py	(revisión: 29)
+++ Lib/distutils/sysconfig.py	(copia de trabajo)
@@ -72,19 +72,21 @@
     if prefix is None:
         prefix = plat_specific and EXEC_PREFIX or PREFIX
 
-    if os.name == "posix":
+    # GCC(mingw): os.name is "nt" but build system is posix
+    if os.name == "posix" or sys.version.find('GCC') >= 0:
         if python_build:
-            buildir = os.path.dirname(sys.executable)
+            # NOTE: sysconfig.py-20091210
+            # Assume the executable is in the build directory.  The
+            # pyconfig.h file should be in the same directory.  Since
+            # the build directory may not be the source directory, we
+            # must use "srcdir" from the makefile to find the "Include"
+            # directory.
+            base = os.path.dirname(os.path.abspath(sys.executable))
             if plat_specific:
-                # python.h is located in the buildir
-                inc_dir = buildir
+                return base
             else:
-                # the source dir is relative to the buildir
-                srcdir = os.path.abspath(os.path.join(buildir,
-                                         get_config_var('srcdir')))
-                # Include is located in the srcdir
-                inc_dir = os.path.join(srcdir, "Include")
-            return inc_dir
+                incdir = os.path.join(get_config_var('srcdir'), 'Include')
+                return os.path.normpath(incdir)
         return os.path.join(prefix, "include", "python" + get_python_version())
     elif os.name == "nt":
         return os.path.join(prefix, "include")
@@ -147,11 +149,22 @@
 
     Mainly needed on Unix, so we can plug in the information that
     varies across Unices and is stored in Python's Makefile.
+
+    NOTE (known limitation of python build/install system):
+    In cross-build environment make macros like CC and LDSHARED
+    contain cross-compiler/linker instead of host compiler/linker.
     """
+    posix_build = None
     if compiler.compiler_type == "unix":
-        (cc, cxx, opt, cflags, ccshared, ldshared, so_ext) = \
+        posix_build = True
+    elif compiler.compiler_type == "mingw32":
+        # GCC(mingw): if build system is posix
+        if sys.version.find('GCC') >= 0:
+            posix_build = True
+    if posix_build == True:
+        (cc, cxx, opt, cflags, ccshared, ldshared, so_ext, ar, ar_flags) = \
             get_config_vars('CC', 'CXX', 'OPT', 'CFLAGS',
-                            'CCSHARED', 'LDSHARED', 'SO')
+                            'CCSHARED', 'LDSHARED', 'SO', 'AR', 'ARFLAGS')
 
         if 'CC' in os.environ:
             cc = os.environ['CC']
@@ -172,6 +185,12 @@
             cpp = cpp + ' ' + os.environ['CPPFLAGS']
             cflags = cflags + ' ' + os.environ['CPPFLAGS']
             ldshared = ldshared + ' ' + os.environ['CPPFLAGS']
+        if 'AR' in os.environ:
+            ar = os.environ['AR']
+        if 'ARFLAGS' in os.environ:
+            archiver = ar + ' ' + os.environ['ARFLAGS']
+        else:
+            archiver = ar + ' ' + ar_flags
 
         cc_cmd = cc + ' ' + cflags
         compiler.set_executables(
@@ -180,7 +199,8 @@
             compiler_so=cc_cmd + ' ' + ccshared,
             compiler_cxx=cxx,
             linker_so=ldshared,
-            linker_exe=cc)
+            linker_exe=cc,
+            archiver=archiver)
 
         compiler.shared_lib_extension = so_ext
 
@@ -188,7 +208,8 @@
 def get_config_h_filename():
     """Return full pathname of installed pyconfig.h file."""
     if python_build:
-        if os.name == "nt":
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == "nt" and sys.version.find('GCC') < 0:
             inc_dir = os.path.join(project_base, "PC")
         else:
             inc_dir = project_base
@@ -436,6 +457,11 @@
 
 def _init_nt():
     """Initialize the module as appropriate for NT"""
+    if sys.version.find('GCC') >= 0:
+        # GCC(mingw) use posix build system
+        # FIXME: may be modification has to be in get_config_vars ?
+        _init_posix()
+        return
     g = {}
     # set basic install directories
     g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
Index: Lib/ctypes/test/test_as_parameter.py
===================================================================
--- Lib/ctypes/test/test_as_parameter.py	(revisión: 29)
+++ Lib/ctypes/test/test_as_parameter.py	(copia de trabajo)
@@ -1,6 +1,7 @@
 import unittest
 from ctypes import *
 import _ctypes_test
+import sys
 
 dll = CDLL(_ctypes_test.__file__)
 
@@ -170,6 +171,10 @@
         s2h = dll.ret_2h_func(self.wrap(inp))
         self.assertEqual((s2h.x, s2h.y), (99*2, 88*3))
 
+    # This is known cdecl incompatibility between GCC
+    # and MSVC. It is addressed in GCC issue #36834.
+    # Python libffi detect it and complain.
+    @unittest.skipIf(sys.platform == "win32" and sys.version.find("GCC") >= 0, 'XFAIL GCC(mingw)')
     def test_struct_return_8H(self):
         class S8I(Structure):
             _fields_ = [("a", c_int),
Index: Lib/ctypes/test/test_functions.py
===================================================================
--- Lib/ctypes/test/test_functions.py	(revisión: 29)
+++ Lib/ctypes/test/test_functions.py	(copia de trabajo)
@@ -358,6 +358,10 @@
             s2h = windll.s_ret_2h_func(S2H(99, 88))
             self.assertEqual((s2h.x, s2h.y), (99*2, 88*3))
 
+    # This is known cdecl incompatibility between GCC
+    # and MSVC. It is addressed in GCC issue #36834.
+    # Python libffi detect it and complain.
+    @unittest.skipIf(sys.platform == "win32" and sys.version.find("GCC") >= 0, 'XFAIL GCC(mingw)')
     def test_struct_return_8H(self):
         class S8I(Structure):
             _fields_ = [("a", c_int),
Index: Lib/ctypes/util.py
===================================================================
--- Lib/ctypes/util.py	(revisión: 29)
+++ Lib/ctypes/util.py	(copia de trabajo)
@@ -7,6 +7,11 @@
 if os.name == "nt":
 
     def _get_build_version():
+        #***********************************************************
+        # NOTE: As example for GCC(mingw) build sys.version return:
+        # '2.7a0 (trunk:<REVISION>M, <DATE>, <TIME>) \n[GCC 3.4.5 (mingw special)]'
+        # '2.7a0 (trunk:<REVISION>M, <DATE>, <TIME>) \n[GCC 4.4.0]'
+        #***********************************************************
         """Return the version of MSVC that was used to build Python.
 
         For Python 2.3 and up, the version number is included in
@@ -30,6 +35,15 @@
         return None
 
     def find_msvcrt():
+        #************************************************************
+        # FIXME: For GCC(mingw) runtime don't depend from compiler
+        # version ;). We may use -D__MSVCRT_VERSION__ to detect which
+        # verion is requested by user, but the name of the library
+        # to be default.
+        # As example WXP is with version 7.0 of msvcrt.dll.
+        # Anyway since _get_build_version return 6 in most(standard)
+        # cases this method will return msvcrt{d}. May be not so bad.
+        #************************************************************
         """Return the name of the VC runtime dll"""
         version = _get_build_version()
         if version is None:
Index: Lib/ctypes/__init__.py
===================================================================
--- Lib/ctypes/__init__.py	(revisión: 29)
+++ Lib/ctypes/__init__.py	(copia de trabajo)
@@ -6,6 +6,13 @@
 import os as _os, sys as _sys
 
 __version__ = "1.1.0"
+import _ctypes
+odlopen = getattr(_ctypes, 'dlopen')
+def __dlopen(name, flag=_ctypes.RTLD_GLOBAL|_ctypes.RTLD_LOCAL):
+  if name:
+    return odlopen(name, flag)
+  return 0L
+_sys.modules["_ctypes"].dlopen=__dlopen
 
 from _ctypes import Union, Structure, Array
 from _ctypes import _Pointer
@@ -438,7 +445,7 @@
 elif _sys.platform == "cygwin":
     pythonapi = PyDLL("libpython%d.%d.dll" % _sys.version_info[:2])
 else:
-    pythonapi = PyDLL(None)
+    pythonapi = PyDLL("libpython%d.%d.so" % _sys.version_info[:2])
 
 
 if _os.name in ("nt", "ce"):
Index: Lib/sysconfig.py
===================================================================
--- Lib/sysconfig.py	(revisión: 29)
+++ Lib/sysconfig.py	(copia de trabajo)
@@ -126,9 +126,14 @@
 
 if _PYTHON_BUILD:
     for scheme in ('posix_prefix', 'posix_home'):
-        _INSTALL_SCHEMES[scheme]['include'] = '{projectbase}/Include'
-        _INSTALL_SCHEMES[scheme]['platinclude'] = '{srcdir}'
+        _INSTALL_SCHEMES[scheme]['include'] = '{srcdir}/Include'
+        _INSTALL_SCHEMES[scheme]['platinclude'] = '{projectbase}'
 
+    # GCC(mingw) use posix build system
+    if os.name == "nt" and sys.version.find('GCC') >= 0:
+        _INSTALL_SCHEMES['nt']['include'] = '{srcdir}/Include'
+        _INSTALL_SCHEMES['nt']['platinclude'] = '{projectbase}'
+
 def _subst_vars(s, local_vars):
     try:
         return s.format(**local_vars)
@@ -351,7 +356,8 @@
 def get_config_h_filename():
     """Returns the path of pyconfig.h."""
     if _PYTHON_BUILD:
-        if os.name == "nt":
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == "nt" and sys.version.find('GCC') < 0:
             inc_dir = os.path.join(_PROJECT_BASE, "PC")
         else:
             inc_dir = _PROJECT_BASE
@@ -413,9 +419,19 @@
         _CONFIG_VARS['platbase'] = _EXEC_PREFIX
         _CONFIG_VARS['projectbase'] = _PROJECT_BASE
 
-        if os.name in ('nt', 'os2'):
+        # GCC(mingw) use posix build system
+        posix_build = None
+        if os.name == 'posix':
+            posix_build = True
+        else:
+            if os.name in ('nt', 'os2'):
+                if sys.version.find('GCC') >= 0:
+                    posix_build = True
+                else:
+                    posix_build = False
+        if posix_build == False:
             _init_non_posix(_CONFIG_VARS)
-        if os.name == 'posix':
+        if posix_build == True:
             _init_posix(_CONFIG_VARS)
 
         # Setting 'userbase' is done below the call to the
@@ -430,7 +446,7 @@
         # Normally it is relative to the build directory.  However, during
         # testing, for example, we might be running a non-installed python
         # from a different directory.
-        if _PYTHON_BUILD and os.name == "posix":
+        if _PYTHON_BUILD and posix_build == True:
             base = _PROJECT_BASE
             try:
                 cwd = os.getcwd()
Index: Lib/test/regrtest.py
===================================================================
--- Lib/test/regrtest.py	(revisión: 29)
+++ Lib/test/regrtest.py	(copia de trabajo)
@@ -388,7 +388,7 @@
             found_garbage = []
 
     if single:
-        filename = os.path.join(TEMPDIR, 'pynexttest')
+        filename = os.path.join(tempfile.gettempdir(), 'pynexttest')
         try:
             fp = open(filename, 'r')
             next_test = fp.read().strip()
@@ -1516,8 +1516,7 @@
     # to keep the test files in a subfolder.  It eases the cleanup of leftover
     # files using command "make distclean".
     if sysconfig.is_python_build():
-        TEMPDIR = os.path.join(sysconfig.get_config_var('srcdir'), 'build')
-        TEMPDIR = os.path.abspath(TEMPDIR)
+        TEMPDIR = os.path.abspath('build')
         if not os.path.exists(TEMPDIR):
             os.mkdir(TEMPDIR)
 
Index: Lib/test/test_sundry.py
===================================================================
--- Lib/test/test_sundry.py	(revisión: 29)
+++ Lib/test/test_sundry.py	(copia de trabajo)
@@ -27,7 +27,11 @@
 
             import distutils.command.bdist_dumb
             if sys.platform.startswith('win'):
-                import distutils.command.bdist_msi
+                try:
+                    import distutils.command.bdist_msi # if msi module is not build
+                except ImportError:
+                    if test_support.verbose:
+                        print "skipping bdist_msi"
             import distutils.command.bdist
             import distutils.command.bdist_rpm
             import distutils.command.bdist_wininst
Index: Lib/test/test_os.py
===================================================================
--- Lib/test/test_os.py	(revisión: 29)
+++ Lib/test/test_os.py	(copia de trabajo)
@@ -324,7 +324,11 @@
 
             def test_large_time(self):
                 t1 = 5000000000 # some day in 2128
-                os.utime(self.fname, (t1, t1))
+                try:
+                    #Note fail if time_t is 32 bit
+                    os.utime(self.fname, (t1, t1))
+                except OverflowError:
+                    self.skipTest("requires at least 64-bit time_t")
                 self.assertEqual(os.stat(self.fname).st_mtime, t1)
 
         def test_1686475(self):
Index: Lib/test/test_curses.py
===================================================================
--- Lib/test/test_curses.py	(revisión: 29)
+++ Lib/test/test_curses.py	(copia de trabajo)
@@ -167,11 +167,16 @@
     curses.delay_output(1)
     curses.echo() ; curses.echo(1)
 
-    f = tempfile.TemporaryFile()
+    fx = tempfile.TemporaryFile()
+    # cf tempfile.py TemporaryFile vs NamedTemporaryFile
+    if os.name != 'posix' or os.sys.platform == 'cygwin':
+        f = fx.file
+    else:
+        f = fx
     stdscr.putwin(f)
     f.seek(0)
     curses.getwin(f)
-    f.close()
+    fx.close()
 
     curses.halfdelay(1)
     curses.intrflush(1)
Index: Makefile.pre.in
===================================================================
--- Makefile.pre.in	(revisión: 29)
+++ Makefile.pre.in	(copia de trabajo)
@@ -182,6 +182,7 @@
 
 PYTHON=		python$(EXE)
 BUILDPYTHON=	python$(BUILDEXE)
+HOSTPYTHON=	./$(BUILDPYTHON)
 
 # The task to run while instrument when building the profile-opt target
 PROFILE_TASK=	$(srcdir)/Tools/pybench/pybench.py -n 2 --with-gc --with-syscheck
@@ -194,7 +195,6 @@
 # Modules
 MODULE_OBJS=	\
 		Modules/config.o \
-		Modules/getpath.o \
 		Modules/main.o \
 		Modules/gcmodule.o
 
@@ -269,7 +269,6 @@
 		Python/codecs.o \
 		Python/errors.o \
 		Python/frozen.o \
-		Python/frozenmain.o \
 		Python/future.o \
 		Python/getargs.o \
 		Python/getcompiler.o \
@@ -405,10 +404,17 @@
 
 
 # Build the shared modules
+# FIXME: in cross-compilation env. (mingw on linux) how to select correct
+# compiler/linker ?
+# The current py-code will created modules with .so suffix and environment
+# variable setting SO=$(SO) don't help.
+# Also it link modules with gcc instead mingw...
 sharedmods: $(BUILDPYTHON)
 	@case $$MAKEFLAGS in \
-	*s*) $(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' ./$(BUILDPYTHON) -E $(srcdir)/setup.py -q build;; \
-	*) $(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' ./$(BUILDPYTHON) -E $(srcdir)/setup.py build;; \
+	*s*) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' $(RUNPYTHON) -E $(srcdir)/setup.py -q build;; \
+	*) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' $(RUNPYTHON) -E $(srcdir)/setup.py build;; \
+	*s*) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' $(RUNPYTHON) -E $(srcdir)/setup.py -q build @PYMOD_BUILDOPT@;; \
+	*) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' $(RUNPYTHON) -E $(srcdir)/setup.py build @PYMOD_BUILDOPT@;; \
 	esac
 
 # Build static library
@@ -526,6 +532,7 @@
 	      -DHGBRANCH="\"`LC_ALL=C $(HGBRANCH)`\"" \
 	      -o $@ $(srcdir)/Modules/getbuildinfo.c
 
+# default sys.path calculations
 Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
 	$(CC) -c $(PY_CFLAGS) -DPYTHONPATH='"$(PYTHONPATH)"' \
 		-DPREFIX='"$(prefix)"' \
@@ -534,15 +541,19 @@
 		-DVPATH='"$(VPATH)"' \
 		-o $@ $(srcdir)/Modules/getpath.c
 
+# default sys.path calculations for windows platforms
+PC/getpathp.o: $(srcdir)/PC/getpathp.c
+	$(CC) -c $(PY_CFLAGS) -o $@ $(srcdir)/PC/getpathp.c
+
 Modules/python.o: $(srcdir)/Modules/python.c
 	$(MAINCC) -c $(PY_CFLAGS) -o $@ $(srcdir)/Modules/python.c
 
 
 # Use a stamp file to prevent make -j invoking pgen twice
 $(GRAMMAR_H) $(GRAMMAR_C): Parser/pgen.stamp
-Parser/pgen.stamp: $(PGEN) $(GRAMMAR_INPUT)
+Parser/pgen.stamp: $(HOSTPGEN) $(GRAMMAR_INPUT)
 		-@$(INSTALL) -d Include
-		$(PGEN) $(GRAMMAR_INPUT) $(GRAMMAR_H) $(GRAMMAR_C)
+		$(HOSTPGEN) $(GRAMMAR_INPUT) $(GRAMMAR_H) $(GRAMMAR_C)
 		-touch Parser/pgen.stamp
 
 $(PGEN):	$(PGENOBJS)
@@ -926,25 +937,25 @@
 	done
 	$(INSTALL_DATA) $(srcdir)/LICENSE $(DESTDIR)$(LIBDEST)/LICENSE.txt
 	PYTHONPATH=$(DESTDIR)$(LIBDEST)  $(RUNSHARED) \
-		./$(BUILDPYTHON) -Wi -tt $(DESTDIR)$(LIBDEST)/compileall.py \
+		$(HOSTPYTHON) -Wi -tt $(DESTDIR)$(LIBDEST)/compileall.py \
 		-d $(LIBDEST) -f \
 		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
 		$(DESTDIR)$(LIBDEST)
 	PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
-		./$(BUILDPYTHON) -Wi -tt -O $(DESTDIR)$(LIBDEST)/compileall.py \
+		$(HOSTPYTHON) -Wi -tt -O $(DESTDIR)$(LIBDEST)/compileall.py \
 		-d $(LIBDEST) -f \
 		-x 'bad_coding|badsyntax|site-packages|lib2to3/tests/data' \
 		$(DESTDIR)$(LIBDEST)
 	-PYTHONPATH=$(DESTDIR)$(LIBDEST)  $(RUNSHARED) \
-		./$(BUILDPYTHON) -Wi -t $(DESTDIR)$(LIBDEST)/compileall.py \
+		$(HOSTPYTHON) -Wi -t $(DESTDIR)$(LIBDEST)/compileall.py \
 		-d $(LIBDEST)/site-packages -f \
 		-x badsyntax $(DESTDIR)$(LIBDEST)/site-packages
 	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
-		./$(BUILDPYTHON) -Wi -t -O $(DESTDIR)$(LIBDEST)/compileall.py \
+		$(HOSTPYTHON) -Wi -t -O $(DESTDIR)$(LIBDEST)/compileall.py \
 		-d $(LIBDEST)/site-packages -f \
 		-x badsyntax $(DESTDIR)$(LIBDEST)/site-packages
 	-PYTHONPATH=$(DESTDIR)$(LIBDEST) $(RUNSHARED) \
-		./$(BUILDPYTHON) -Wi -t -c "import lib2to3.pygram, lib2to3.patcomp;lib2to3.patcomp.PatternCompiler()"
+		$(HOSTPYTHON) -Wi -t -c "import lib2to3.pygram, lib2to3.patcomp;lib2to3.patcomp.PatternCompiler()"
 
 # Create the PLATDIR source directory, if one wasn't distributed..
 $(srcdir)/Lib/$(PLATDIR):
@@ -1049,7 +1060,7 @@
 # Install the dynamically loadable modules
 # This goes into $(exec_prefix)
 sharedinstall: sharedmods
-	$(RUNSHARED) ./$(BUILDPYTHON) -E $(srcdir)/setup.py install \
+	$(RUNSHARED) $(HOSTPYTHON) -E $(srcdir)/setup.py install \
 	   	--prefix=$(prefix) \
 		--install-scripts=$(BINDIR) \
 		--install-platlib=$(DESTSHARED) \
Index: Modules/_ctypes/_ctypes.c
===================================================================
--- Modules/_ctypes/_ctypes.c	(revisión: 29)
+++ Modules/_ctypes/_ctypes.c	(copia de trabajo)
@@ -3166,11 +3166,27 @@
     mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \0 _ @ %d */
     if (!mangled_name)
         return NULL;
+    /* FIXME: for stdcall decorated export functions MSVC compiler add
+     * underscore, but GCC compiler create them without.
+     * As well functions from system libraries are without underscore.
+     * This is visible by example for _ctypes_test.pyd module.
+     * Solutions:
+     * - If a python module is build with gcc option --add-stdcall-alias
+     * the module will contain XXX as alias for function XXX@ as result
+     * first search in this method will succeed.
+     * - Distutil may use compiler to create def-file, to modify it as
+     * add underscore alias and with new def file to create module.
+     * - Or may be just to search for function without underscore.
+     */
     for (i = 0; i < 32; ++i) {
         sprintf(mangled_name, "_%s@%d", name, i*4);
         address = (PPROC)GetProcAddress(handle, mangled_name);
         if (address)
             return address;
+        sprintf(mangled_name, "%s@%d", name, i*4);
+        address = (PPROC)GetProcAddress(handle, mangled_name);
+        if (address)
+            return address;
     }
     return NULL;
 #endif
Index: Modules/_io/_iomodule.h
===================================================================
--- Modules/_io/_iomodule.h	(revisión: 29)
+++ Modules/_io/_iomodule.h	(copia de trabajo)
@@ -72,7 +72,7 @@
     PyObject *filename; /* Not used, but part of the IOError object */
     Py_ssize_t written;
 } PyBlockingIOErrorObject;
-PyAPI_DATA(PyObject *) PyExc_BlockingIOError;
+extern PyObject* PyExc_BlockingIOError;
 
 /*
  * Offset type for positioning.
Index: Modules/_io/fileio.c
===================================================================
--- Modules/_io/fileio.c	(revisión: 29)
+++ Modules/_io/fileio.c	(copia de trabajo)
@@ -29,7 +29,9 @@
 
 #ifdef MS_WINDOWS
 /* can simulate truncate with Win32 API functions; see file_truncate */
+#ifndef HAVE_FTRUNCATE
 #define HAVE_FTRUNCATE
+#endif
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
Index: Modules/_localemodule.c
===================================================================
--- Modules/_localemodule.c	(revisión: 29)
+++ Modules/_localemodule.c	(copia de trabajo)
@@ -10,6 +10,13 @@
 ******************************************************************/
 
 #include "Python.h"
+#ifdef __MINGW32__
+/* The header libintl.h and library libintl may exist on mingw host.
+ * To be compatible with MSVC build we has to undef some defines.
+ */
+#undef HAVE_LIBINTL_H
+#undef HAVE_BIND_TEXTDOMAIN_CODESET
+#endif
 
 #include <stdio.h>
 #include <locale.h>
@@ -205,6 +212,7 @@
 static PyObject*
 PyLocale_localeconv(PyObject* self)
 {
+#ifndef ANDROID
     PyObject* result;
     struct lconv *l;
     PyObject *x;
@@ -265,6 +273,7 @@
   failed:
     Py_XDECREF(result);
     Py_XDECREF(x);
+#endif
     return NULL;
 }
 
Index: Modules/termios.c
===================================================================
--- Modules/termios.c	(revisión: 29)
+++ Modules/termios.c	(copia de trabajo)
@@ -227,6 +227,7 @@
     return Py_None;
 }
 
+#ifndef ANDROID
 PyDoc_STRVAR(termios_tcdrain__doc__,
 "tcdrain(fd) -> None\n\
 \n\
@@ -246,6 +247,7 @@
     Py_INCREF(Py_None);
     return Py_None;
 }
+#endif
 
 PyDoc_STRVAR(termios_tcflush__doc__,
 "tcflush(fd, queue) -> None\n\
@@ -301,8 +303,10 @@
      METH_VARARGS, termios_tcsetattr__doc__},
     {"tcsendbreak", termios_tcsendbreak,
      METH_VARARGS, termios_tcsendbreak__doc__},
+#ifndef ANDROID
     {"tcdrain", termios_tcdrain,
      METH_VARARGS, termios_tcdrain__doc__},
+#endif
     {"tcflush", termios_tcflush,
      METH_VARARGS, termios_tcflush__doc__},
     {"tcflow", termios_tcflow,
Index: Modules/readline.c
===================================================================
--- Modules/readline.c	(revisión: 29)
+++ Modules/readline.c	(copia de trabajo)
@@ -11,6 +11,11 @@
 #include <errno.h>
 #include <sys/time.h>
 
+#ifdef MS_WINDOWS
+/* on windows select don't work on files */
+#undef HAVE_SELECT
+#endif
+
 #if defined(HAVE_SETLOCALE)
 /* GNU readline() mistakenly sets the LC_CTYPE locale.
  * This is evil.  Only the user or the app's main() should do this!
@@ -880,6 +885,10 @@
     /* Allow $if term= in .inputrc to work */
     rl_terminal_name = getenv("TERM");
 #endif
+#ifdef MS_WINDOWS
+    /* FIXME: need more test before to skip this hack */
+    rl_terminal_name = "dumb";
+#endif
     /* Force rebind of TAB to insert-tab */
     rl_bind_key('\t', rl_insert);
     /* Bind both ESC-TAB and ESC-ESC to the completion function */
@@ -1139,6 +1148,9 @@
 
 
 
+#ifndef MS_WINDOWS
+    /* FIXME: windows readline(prompt) may not work ? */
     PyOS_ReadlineFunctionPointer = call_readline;
+#endif
     setup_readline();
 }
Index: Modules/selectmodule.c
===================================================================
--- Modules/selectmodule.c	(revisión: 29)
+++ Modules/selectmodule.c	(copia de trabajo)
@@ -111,9 +111,10 @@
         v = PyObject_AsFileDescriptor( o );
         if (v == -1) goto finally;
 
-#if defined(_MSC_VER)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+/* FIXME: why not #ifdef Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE ? */
         max = 0;                             /* not used for Win32 */
-#else  /* !_MSC_VER */
+#else  /* !_MSC_VER & !__MINGW32__ */
         if (v < 0 || v >= FD_SETSIZE) {
             PyErr_SetString(PyExc_ValueError,
                         "filedescriptor out of range in select()");
@@ -121,7 +122,7 @@
         }
         if (v > max)
             max = v;
-#endif /* _MSC_VER */
+#endif /* _MSC_VER, __MINGW32__ */
         FD_SET(v, set);
 
         /* add object and its file descriptor to the list */
@@ -164,7 +165,8 @@
     for (j = 0; fd2obj[j].sentinel >= 0; j++) {
         fd = fd2obj[j].fd;
         if (FD_ISSET(fd, set)) {
-#ifndef _MSC_VER
+#if !defined(_MSC_VER) && !defined(__MINGW32__)
+/* FIXME: why not #ifndef Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE ? */
             if (fd > FD_SETSIZE) {
                 PyErr_SetString(PyExc_SystemError,
                "filedescriptor out of range returned in select()");
Index: Modules/signalmodule.c
===================================================================
--- Modules/signalmodule.c	(revisión: 29)
+++ Modules/signalmodule.c	(copia de trabajo)
@@ -7,7 +7,7 @@
 #include "intrcheck.h"
 
 #ifdef MS_WINDOWS
-#include <Windows.h>
+#include <windows.h>
 #ifdef HAVE_PROCESS_H
 #include <process.h>
 #endif
Index: Modules/pwdmodule.c
===================================================================
--- Modules/pwdmodule.c	(revisión: 29)
+++ Modules/pwdmodule.c	(copia de trabajo)
@@ -68,14 +68,14 @@
 #define SETS(i,val) sets(v, i, val)
 
     SETS(setIndex++, p->pw_name);
-#ifdef __VMS
+#if defined(__VMS) || defined(ANDROID)
     SETS(setIndex++, "");
 #else
     SETS(setIndex++, p->pw_passwd);
 #endif
     SETI(setIndex++, p->pw_uid);
     SETI(setIndex++, p->pw_gid);
-#ifdef __VMS
+#if defined(__VMS) || defined(ANDROID)
     SETS(setIndex++, "");
 #else
     SETS(setIndex++, p->pw_gecos);
Index: Modules/mathmodule.c
===================================================================
--- Modules/mathmodule.c	(revisión: 29)
+++ Modules/mathmodule.c	(copia de trabajo)
@@ -60,6 +60,30 @@
 extern double copysign(double, double);
 #endif
 
+#if defined(__MINGW32__)
+#  define USE_MINGWEX_MATH
+#endif
+
+#ifdef USE_MINGWEX_MATH
+/* Since ldexp() is broken on many MSVCRT implementations and mingwex
+ * library provide a long double version we will use it as work-around.
+ * As example broken ldexp return for ldexp(1., INT_MAX) 0(zero) instead inf.
+ * With this work-around math test testLdexp pass.
+ */
+static double fake_ldexp (double x, int expn) { return ldexpl (x, expn); }
+#define ldexp	fake_ldexp
+
+/* Since pow() is broken on many MSVCRT implementations and library
+ * mingwex provide a long double version we will use it as work-around.
+ * As example broken pow return for pow(132.97585637020967, 126.95117632943295)
+ * 4.1252919849060512e+269 instead 4.1252919849057403e+269.
+ * With this work-around math test test_mtestfile pass for gamma.
+ */
+static double fake_pow (double x, double y) { return powl (x, y); }
+#define pow	fake_pow
+
+#endif /*def USE_MINGWEX_MATH*/
+
 /*
    sin(pi*x), giving accurate results for all finite x (especially x
    integral or close to an integer).  This is here for use in the
Index: Modules/socketmodule.c
===================================================================
--- Modules/socketmodule.c	(revisión: 29)
+++ Modules/socketmodule.c	(copia de trabajo)
@@ -91,6 +91,15 @@
 #endif
 
 #include "Python.h"
+#ifndef HAVE_GETPEERNAME
+/* FIXME: see comments in configure.in. Also PC/pyconfig.h define it.
+ * Since only this module use getpeername why don't remove declaration
+ * from PC/pyconfig.h and define here if is defined MS_WIN32 ?
+ */
+#ifdef __MINGW32__
+#  define HAVE_GETPEERNAME
+#endif
+#endif /* ndef HAVE_GETPEERNAME */
 #include "structmember.h"
 
 #undef MAX
@@ -312,7 +321,36 @@
   /* Do not include addrinfo.h for MSVC7 or greater. 'addrinfo' and
    * EAI_* constants are defined in (the already included) ws2tcpip.h.
    */
+#elif defined(__MINGW32__)
+/* FIXME: getaddrinfo(HAVE_GETADDRINFO) depend from WINVER
+   TODO: resolve later(see comments in pyport.h) */
+#if 0
+/* To use getaddrinfo/getnameinfo from runtime for version before 0x0501
+   we has to define those functions (see below).
+   In all cases mingw linker succeed to link binaries.
+   If you enable this code the load of module will fail on w2k
+   with message like this one:
+   "The specified procedure could not be found" */
+#  if (_WIN32_WINNT < 0x0501)
+void WSAAPI freeaddrinfo (struct addrinfo*);
+int WSAAPI getaddrinfo (const char*,const char*,const struct addrinfo*,
+		        struct addrinfo**);
+int WSAAPI getnameinfo(const struct sockaddr*,socklen_t,char*,DWORD,
+		       char*,DWORD,int);
+#  endif
+#  define HAVE_GETADDRINFO
+#  define HAVE_GETNAMEINFO
 #else
+#  if (_WIN32_WINNT < 0x0501)
+   /* Internal implemetation that has to work on w2k and latest. */
+#    define EAI_ADDRFAMILY
+#    include "addrinfo.h"
+#  else
+#    define HAVE_GETADDRINFO
+#    define HAVE_GETNAMEINFO
+#  endif
+#endif
+#else
 #  include "addrinfo.h"
 #endif
 
@@ -349,6 +387,16 @@
 #if !defined(HAVE_GETADDRINFO)
 /* avoid clashes with the C library definition of the symbol. */
 #define getaddrinfo fake_getaddrinfo
+#ifdef __MINGW32__
+#ifdef gai_strerror
+/* NOTE: Mingw w32api always define gai_strerror to gai_strerror{A|W}
+   but getaddrinfo is defined if _WIN32_WINNT >= 0x0501.
+   MSDN say that gai_strerror() exist for w95 and later and
+   getaddrinfo()/getnameinfo() for wxp and later.
+   Since we use fake function to suppress warnign we has to undef. */
+#  undef gai_strerror
+#endif
+#endif /*def __MINGW32__*/
 #define gai_strerror fake_gai_strerror
 #define freeaddrinfo fake_freeaddrinfo
 #include "getaddrinfo.c"
@@ -2909,7 +2957,31 @@
 Shut down the reading side of the socket (flag == SHUT_RD), the writing side\n\
 of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).");
 
+#ifndef SIO_RCVALL
+#ifdef __MINGW32__
+/* MSDN: SIO_RCVALL defined on w2k and later */
+/* note "Separate SDKs" required for w2k    */
+/* 0x98000001 = _WSAIOW(IOC_VENDOR,1)       */
+#  define SIO_RCVALL	0x98000001
+#  define RCVALL_OFF	0
+#  define RCVALL_ON	1
+   /* NOTE: MSDN - this feature is not implemented */
+#  define RCVALL_SOCKETLEVELONLY	2
+
+/* 0x98000004 = _WSAIOW(IOC_VENDOR,4) */
+#  define SIO_KEEPALIVE_VALS	0x98000004
+struct tcp_keepalive {
+    u_long onoff;
+    u_long keepalivetime;
+    u_long keepaliveinterval;
+};
+#endif /* def __MINGW32__ */
+#endif /* ndef SIO_RCVALL */
+
 #if defined(MS_WINDOWS) && defined(SIO_RCVALL)
+/* If isn't defined test_socket.py fail with:
+AttributeError: type object '_socket.socket' has no attribute 'ioctl'
+*/
 static PyObject*
 sock_ioctl(PySocketSockObject *s, PyObject *arg)
 {
Index: Modules/socketmodule.h
===================================================================
--- Modules/socketmodule.h	(revisión: 29)
+++ Modules/socketmodule.h	(copia de trabajo)
@@ -13,6 +13,13 @@
 # endif
 
 #else /* MS_WINDOWS */
+#ifdef socklen_t
+/* Configure script define to int on windows for GCC compiler.
+   Avoid GCC 4.4+ error (two or more data types in declaration specifiers)
+   as undef it first.
+ */
+# undef socklen_t
+#endif
 # include <winsock2.h>
 # include <ws2tcpip.h>
 /* VC6 is shipped with old platform headers, and does not have MSTcpIP.h
Index: Modules/_multiprocessing/multiprocessing.c
===================================================================
--- Modules/_multiprocessing/multiprocessing.c	(revisión: 29)
+++ Modules/_multiprocessing/multiprocessing.c	(copia de trabajo)
@@ -309,6 +309,12 @@
         Py_DECREF(temp); Py_DECREF(value); return; }              \
     Py_DECREF(value)
 
+#ifndef MS_WINDOWS
+/* GCC(mingw) 4.4+ require and use posix threads(pthreads-w32)
+ * Also system may contain installed pthreads-w32.
+ * As multiprocessing is based on windows methods we must
+ * comment all those flags
+ */
 #if defined(HAVE_SEM_OPEN) && !defined(POSIX_SEMAPHORES_NOT_ENABLED)
     ADD_FLAG(HAVE_SEM_OPEN);
 #endif
@@ -322,8 +328,10 @@
     ADD_FLAG(HAVE_BROKEN_SEM_GETVALUE);
 #endif
 #ifdef HAVE_BROKEN_SEM_UNLINK
+/* FIXME: why use this? Note before was for cygwin and darwin ? */
     ADD_FLAG(HAVE_BROKEN_SEM_UNLINK);
 #endif
+#endif /*ndef MS_WINDOWS*/
     if (PyModule_AddObject(module, "flags", temp) < 0)
         return;
 }
Index: Modules/Setup.dist
===================================================================
--- Modules/Setup.dist	(revisión: 29)
+++ Modules/Setup.dist	(copia de trabajo)
@@ -112,9 +112,10 @@
 # This only contains the minimal set of modules required to run the 
 # setup.py script in the root of the Python source tree.
 
-posix posixmodule.c		# posix (UNIX) system calls
 errno errnomodule.c		# posix (UNIX) errno values
-pwd pwdmodule.c			# this is needed to find out the user's home dir
+#FIXME: setup.py detect this module along with grp and spwd.
+#FIXME: what about to comment ?
+#pwd pwdmodule.c			# this is needed to find out the user's home dir
 				# if $HOME is not set
 _sre _sre.c			# Fredrik Lundh's new regular expressions
 _codecs _codecsmodule.c		# access to the builtin codecs and codec registry
Index: Modules/_math.c
===================================================================
--- Modules/_math.c	(revisión: 29)
+++ Modules/_math.c	(copia de trabajo)
@@ -5,6 +5,29 @@
 #include <float.h>
 #include "_math.h"
 
+#if defined(__MINGW32__)
+#  define USE_MINGWEX_MATH
+#endif
+
+#ifdef USE_MINGWEX_MATH
+/* To avoid problems with many MSVCRT implementations we will
+ * use a work-around
+ */
+#define MAXLOG 7.09782712893383996843E2
+#define MINLOG -7.45133219101941108420E2
+
+static double fake_exp (double x) {
+  if (isnan(x)) { return(x); }
+  if (isinf(x)) { return(x > 0.0 ? x : 0.0); }
+  if (x > MAXLOG) { errno = ERANGE; return(INFINITY); }
+/* the correct code is to set ERANGE but why windows build bot don't fail ? */
+  if (x < MINLOG) { errno = ERANGE; return(0.0); }
+
+  return(exp(x));
+}
+#define exp	fake_exp
+#endif /*def USE_MINGWEX_MATH*/
+
 /* The following copyright notice applies to the original
    implementations of acosh, asinh and atanh. */
 
@@ -179,9 +202,28 @@
         if (u == 1.0)
             return x;
         else
+#if 0
             return (u - 1.0) * x / log(u);
+#else
+        {   /* avoid precision error */
+            double r;
+            r = x / log(u);
+            return((u - 1.0) * r);
+        }
+#endif
     }
     else
+#ifdef USE_MINGWEX_MATH
+/* to avout errors with correct fake_exp:
+  expm10211:expm1(-1420.0): expected -1.0, got 'OverflowError'
+  expm10212:expm1(-1450.0): expected -1.0, got 'OverflowError'
+  expm10213:expm1(-1500.0): expected -1.0, got 'OverflowError'
+  expm10214:expm1(-1e+50): expected -1.0, got 'OverflowError'
+  expm10215:expm1(-1.79e+308): expected -1.0, got 'OverflowError'
+*/
+        if (x < MINLOG) { return(-1.0); }
+        else
+#endif
         return exp(x) - 1.0;
 }
 
Index: Modules/getnameinfo.c
===================================================================
--- Modules/getnameinfo.c	(revisión: 29)
+++ Modules/getnameinfo.c	(copia de trabajo)
@@ -48,6 +48,14 @@
 #include "addrinfo.h"
 #endif
 
+#ifndef IN_EXPERIMENTAL
+#define IN_EXPERIMENTAL(i)  (((i) & 0xe0000000U) == 0xe0000000U)
+#endif
+
+#ifndef IN_LOOPBACKNET
+#define IN_LOOPBACKNET	    127
+#endif
+
 #define SUCCESS 0
 #define YES 1
 #define NO  0
Index: Modules/Setup.config.in
===================================================================
--- Modules/Setup.config.in	(revisión: 29)
+++ Modules/Setup.config.in	(copia de trabajo)
@@ -3,11 +3,22 @@
 # The purpose of this file is to conditionally enable certain modules
 # based on configure-time options.
 
+# init system calls(posix/nt/...) for INITFUNC (used by makesetup)
+#nt posixmodule.c
+
 # Threading
 @USE_THREAD_MODULE@thread threadmodule.c
 
 # The signal module
 @USE_SIGNAL_MODULE@signal signalmodule.c
 
+# On win32 host(mingw build in MSYS environment) show that site.py
+# fail to load if some modules are not build-in:
+BUILDIN_WIN32_MODULE=_functools _functoolsmodule.c	# Tools for working with functions and callable objects
+BUILDIN_WIN32_MODULE=operator operator.c	# operator.add() and similar goodies
+BUILDIN_WIN32_MODULE=_locale _localemodule.c	# -lintl
+BUILDIN_WIN32_MODULE=_winreg ../PC/_winreg.c
+
+
 # The rest of the modules previously listed in this file are built
 # by the setup.py script in Python 2.1 and later.
Index: Modules/posixmodule.c
===================================================================
--- Modules/posixmodule.c	(revisión: 29)
+++ Modules/posixmodule.c	(copia de trabajo)
@@ -130,6 +130,16 @@
 #define HAVE_CWAIT      1
 #define HAVE_FSYNC      1
 #define fsync _commit
+#elif defined(__MINGW32__)	/* GCC (mingw special) compiler */
+/*#define HAVE_GETCWD	1 - detected by configure*/
+#define HAVE_SPAWNV	1
+/*#define HAVE_EXECV	1 - detected by configure*/
+#define HAVE_PIPE	1
+#define HAVE_POPEN	1
+#define HAVE_SYSTEM	1
+#define HAVE_CWAIT	1
+#define HAVE_FSYNC	1
+#define fsync _commit
 #else
 #if defined(PYOS_OS2) && defined(PYCC_GCC) || defined(__VMS)
 /* Everything needed is defined in PC/os2emx/pyconfig.h or vms/pyconfig.h */
@@ -155,6 +165,9 @@
 #define HAVE_SYSTEM     1
 #define HAVE_WAIT       1
 #define HAVE_TTYNAME    1
+#ifdef ANDROID
+    #undef HAVE_TTYNAME
+#endif
 #endif  /* PYOS_OS2 && PYCC_GCC && __VMS */
 #endif  /* _MSC_VER */
 #endif  /* __BORLANDC__ */
@@ -258,7 +271,7 @@
 #endif
 #endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__MINGW32__)
 #ifdef HAVE_DIRECT_H
 #include <direct.h>
 #endif
@@ -274,7 +287,7 @@
 #include <shellapi.h>   /* for ShellExecute() */
 #define popen   _popen
 #define pclose  _pclose
-#endif /* _MSC_VER */
+#endif /* _MSC_VER || __MINGW32__ */
 
 #if defined(PYCC_VACPP) && defined(PYOS_OS2)
 #include <io.h>
@@ -463,7 +476,7 @@
 */
 #include <crt_externs.h>
 static char **environ;
-#elif !defined(_MSC_VER) && ( !defined(__WATCOMC__) || defined(__QNX__) )
+#elif !defined(_MSC_VER) && !defined(__MINGW32__) && ( !defined(__WATCOMC__) || defined(__QNX__) )
 extern char **environ;
 #endif /* !_MSC_VER */
 
@@ -3787,7 +3800,7 @@
     slave_fd = open(slave_name, O_RDWR | O_NOCTTY); /* open slave */
     if (slave_fd < 0)
         return posix_error();
-#if !defined(__CYGWIN__) && !defined(HAVE_DEV_PTC)
+#if !defined(__CYGWIN__) && !defined(HAVE_DEV_PTC) && !defined(ANDROID)
     ioctl(slave_fd, I_PUSH, "ptem"); /* push ptem */
     ioctl(slave_fd, I_PUSH, "ldterm"); /* push ldterm */
 #ifndef __hpux
@@ -8477,6 +8490,13 @@
 #endif
 
 #ifdef MS_WINDOWS
+#ifdef __MINGW32__
+/* NOTE: All sample MSDN wincrypt programs include this header.
+ * It is required if we use mingw w32api.
+ * Why MSVC builds don't include it ?
+ */
+#  include <wincrypt.h>
+#endif
 
 PyDoc_STRVAR(win32_urandom__doc__,
 "urandom(n) -> str\n\n\
@@ -9276,7 +9296,7 @@
 }
 
 
-#if (defined(_MSC_VER) || defined(__WATCOMC__) || defined(__BORLANDC__)) && !defined(__QNX__)
+#if (defined(_MSC_VER) || defined (__MINGW32__) || defined(__WATCOMC__) || defined(__BORLANDC__)) && !defined(__QNX__)
 #define INITFUNC initnt
 #define MODNAME "nt"
 
Index: Modules/getaddrinfo.c
===================================================================
--- Modules/getaddrinfo.c	(revisión: 29)
+++ Modules/getaddrinfo.c	(copia de trabajo)
@@ -232,6 +232,9 @@
     return YES;
 }
 
+#ifndef EAI_BADHINTS
+#  define EAI_BADHINTS EAI_BADFLAGS
+#endif
 int
 getaddrinfo(const char*hostname, const char*servname,
             const struct addrinfo *hints, struct addrinfo **res)
Index: pyconfig.h.in
===================================================================
--- pyconfig.h.in	(revisión: 29)
+++ pyconfig.h.in	(copia de trabajo)
@@ -49,7 +49,7 @@
 /* Define to 1 if you have the `acosh' function. */
 #undef HAVE_ACOSH
 
-/* struct addrinfo (netdb.h) */
+/* struct addrinfo */
 #undef HAVE_ADDRINFO
 
 /* Define to 1 if you have the `alarm' function. */
@@ -885,6 +885,9 @@
 /* Define to 1 if you have the `wcscoll' function. */
 #undef HAVE_WCSCOLL
 
+/* Define to 1 if you have the <winsock2.h> header file. */
+#undef HAVE_WINSOCK2_H
+
 /* Define if tzset() actually switches the local timezone in a meaningful way.
    */
 #undef HAVE_WORKING_TZSET
@@ -912,6 +915,9 @@
 /* Define if mvwdelch in curses.h is an expression. */
 #undef MVWDELCH_IS_EXPRESSION
 
+/* Define to 1 if you want to use native NT threads */
+#undef NT_THREADS
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
